//  The MIT License (MIT)

//  Chess Engine Yakka
//  Copyright (c) 2024 Christopher Crone

//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:

//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.

//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.


unit Eval;

interface

Uses
  Winapi.Windows, System.Classes, System.Math, System.SysUtils, Common,

  GameDef, EndGame;


type
  TEvalRec = record
    UID : UInt64;
    Data : UInt64;
    end;


type
  T_EvalHash_Table = record
    const
      TableSize = $40000;             // 2^18       = 262,144 slots
      TableMask = TableSize - 1 ;     // 2^18 - 1

    var
    Table : Array[0..TableSize-1] of TEvalRec;

    function RetrieveScore(HashCode : UInt64; var score : integer) : boolean;
    procedure StoreScore(HashCode : UInt64; score : integer);
    procedure ClearTable;
    end;


type
  TPawnRec = record
    UID : UInt64;
    Data : UInt64;
    end;

type
  T_PawnHash_Table = record
    const
      TableSize = $8000;             // 2^15       = 32,768 slots
      TableMask = TableSize - 1 ;    // 2^15 - 1

    var
    Table : Array[0..TableSize-1] of TPawnRec;

    function RetrieveData(HashCode : UInt64; var score : integer; var Passers : UInt64) : boolean;
    procedure StoreData(HashCode : UInt64; score : integer; Passers : UInt64);
    procedure ClearTable;
    end;


const
    FlipLookup : array[0..63] of integer =
        (56, 57, 58, 59, 60, 61, 62, 63,
         48, 49, 50, 51, 52, 53, 54, 55,
         40, 41, 42, 43, 44, 45, 46, 47,
         32, 33, 34, 35, 36, 37, 38, 39,
         24, 25, 26, 27, 28, 29, 30, 31,
         16, 17, 18, 19, 20, 21, 22, 23,
          8,  9, 10, 11, 12, 13, 14, 15,
          0,  1,  2,  3,  4,  5,  6,  7);


    Board_Centre_4      = UInt64($0000001818000000);
    Board_Centre_12     = UInt64($0000183C3C180000);
    Board_Centre_16     = UInt64($00003C3C3C3C0000);

    Board_Centre_Ext    = UInt64($00183C7E7E3C1800);

    Board_Top_Half    = UInt64($00000000FFFFFFFF);   //   5..8
    Board_Bottom_Half = UInt64($FFFFFFFF00000000);   //   1..4
    Board_Left_Half   = UInt64($0F0F0F0F0F0F0F0F);   //   a..d
    Board_Right_Half  = UInt64($F0F0F0F0F0F0F0F0);   //   e..h

    Board_White =  UInt64($AA55AA55AA55AA55);
    Board_Black =  UInt64($55AA55AA55AA55AA);

    Board_LeftEdge = UInt64($0101010101010101);
    Board_RightEdge  = UInt64($8080808080808080);


    AdjacentFiles : array[0..7] of UInt64 =
     ($0202020202020202,
      $0505050505050505,
      $0A0A0A0A0A0A0A0A,
      $1414141414141414,
      $2828282828282828,
      $5050505050505050,
      $A0A0A0A0A0A0A0A0,
      $4040404040404040);


   KingAttackMask : array[0..63] of UInt64 =
     	($0000000000000302, $0000000000000705, $0000000000000E0A, $0000000000001C14, $0000000000003828, $0000000000007050, $000000000000E0A0, $000000000000C040,
	     $0000000000030203, $0000000000070507, $00000000000E0A0E, $00000000001C141C, $0000000000382838, $0000000000705070, $0000000000E0A0E0, $0000000000C040C0,
	     $0000000003020300, $0000000007050700, $000000000E0A0E00, $000000001C141C00, $0000000038283800, $0000000070507000, $00000000E0A0E000, $00000000C040C000,
	     $0000000302030000, $0000000705070000, $0000000E0A0E0000, $0000001C141C0000, $0000003828380000, $0000007050700000, $000000E0A0E00000, $000000C040C00000,
	     $0000030203000000, $0000070507000000, $00000E0A0E000000, $00001C141C000000, $0000382838000000, $0000705070000000, $0000E0A0E0000000, $0000C040C0000000,
	     $0003020300000000, $0007050700000000, $000E0A0E00000000, $001C141C00000000, $0038283800000000, $0070507000000000, $00E0A0E000000000, $00C040C000000000,
	     $0302030000000000, $7050700000000000, $E0A0E00000000000, $1C141C0000000000, $3828380000000000, $7050700000000000, $E0A0E00000000000, $C040C00000000000,
	     $0203000000000000, $0507000000000000, $0A0E000000000000, $141C000000000000, $2838000000000000, $5070000000000000, $A0E0000000000000, $40C0000000000000);


    BlackPassMask : array[0..63] of UInt64 =
     ($0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000,
      $0303030303030000, $0707070707070000, $0E0E0E0E0E0E0000, $1C1C1C1C1C1C0000, $3838383838380000, $7070707070700000, $E0E0E0E0E0E00000, $C0C0C0C0C0C00000,
      $0303030303000000, $0707070707000000, $0E0E0E0E0E000000, $1C1C1C1C1C000000, $3838383838000000, $7070707070000000, $E0E0E0E0E0000000, $C0C0C0C0C0000000,
      $0303030300000000, $0707070700000000, $0E0E0E0E00000000, $1C1C1C1C00000000, $3838383800000000, $7070707000000000, $E0E0E0E000000000, $C0C0C0C000000000,
      $0303030000000000, $0707070000000000, $0E0E0E0000000000, $1C1C1C0000000000, $3838380000000000, $7070700000000000, $E0E0E00000000000, $C0C0C00000000000,
      $0303000000000000, $0707000000000000, $0E0E000000000000, $1C1C000000000000, $3838000000000000, $7070000000000000, $E0E0000000000000, $C0C0000000000000,
      $0300000000000000, $0700000000000000, $0E00000000000000, $1C00000000000000, $3800000000000000, $7000000000000000, $E000000000000000, $C000000000000000,
      $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000);

    WhitePassMask : array[0..63] of UInt64 =
     ($0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000,
      $0000000000000003, $0000000000000007, $000000000000000E, $000000000000001C, $0000000000000038, $0000000000000070, $00000000000000E0, $00000000000000C0,
      $0000000000000303, $0000000000000707, $0000000000000E0E, $0000000000001C1C, $0000000000003838, $0000000000007070, $000000000000E0E0, $000000000000C0C0,
      $0000000000030303, $0000000000070707, $00000000000E0E0E, $00000000001C1C1C, $0000000000383838, $0000000000707070, $0000000000E0E0E0, $0000000000C0C0C0,
      $0000000003030303, $0000000007070707, $000000000E0E0E0E, $000000001C1C1C1C, $0000000038383838, $0000000070707070, $00000000E0E0E0E0, $00000000C0C0C0C0,
      $0000000303030303, $0000000707070707, $0000000E0E0E0E0E, $0000001C1C1C1C1C, $0000003838383838, $0000007070707070, $000000E0E0E0E0E0, $000000C0C0C0C0C0,
      $0000030303030303, $0000070707070707, $00000E0E0E0E0E0E, $00001C1C1C1C1C1C, $0000383838383838, $0000707070707070, $0000E0E0E0E0E0E0, $0000C0C0C0C0C0C0,
      $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000);

    BlackSpanMask : array[0..63] of UInt64 =
     ($0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000,
      $0101010101010000, $0202020202020000, $0404040404040000, $0808080808080000, $1010101010100000, $2020202020200000, $4040404040400000, $8080808080800000,
      $0101010101000000, $0202020202000000, $0404040404000000, $0808080808000000, $1010101010000000, $2020202020000000, $4040404040000000, $8080808080000000,
      $0101010100000000, $0202020200000000, $0404040400000000, $0808080800000000, $1010101000000000, $2020202000000000, $4040404000000000, $8080808000000000,
      $0101010000000000, $0202020000000000, $0404040000000000, $0808080000000000, $1010100000000000, $2020200000000000, $4040400000000000, $8080800000000000,
      $0101000000000000, $0202000000000000, $0404000000000000, $0808000000000000, $1010000000000000, $2020000000000000, $4040000000000000, $8080000000000000,
      $0100000000000000, $0200000000000000, $0400000000000000, $0800000000000000, $1000000000000000, $2000000000000000, $4000000000000000, $8000000000000000,
      $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000);

    WhiteSpanMask : array[0..63] of UInt64 =
     ($0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000,
      $0000000000000001, $0000000000000002, $0000000000000004, $0000000000000008, $0000000000000010, $0000000000000020, $0000000000000040, $0000000000000080,
      $0000000000000101, $0000000000000202, $0000000000000404, $0000000000000808, $0000000000001010, $0000000000002020, $0000000000004040, $0000000000008080,
      $0000000000010101, $0000000000020202, $0000000000040404, $0000000000080808, $0000000000101010, $0000000000202020, $0000000000404040, $0000000000808080,
      $0000000001010101, $0000000002020202, $0000000004040404, $0000000008080808, $0000000010101010, $0000000020202020, $0000000040404040, $0000000080808080,
      $0000000101010101, $0000000202020202, $0000000404040404, $0000000808080808, $0000001010101010, $0000002020202020, $0000004040404040, $0000008080808080,
      $0000010101010101, $0000020202020202, $0000040404040404, $0000080808080808, $0000101010101010, $0000202020202020, $0000404040404040, $0000808080808080,
      $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000);


    IsolatedPawnMask : array[0..7] of UInt64 =
       ($0202020202020202,
        $0505050505050505,
        $0A0A0A0A0A0A0A0A,
        $1414141414141414,
        $2828282828282828,
        $5050505050505050,
        $A0A0A0A0A0A0A0A0,
        $4040404040404040);

    DoubledPawnMask : array[0..7] of UInt64 =
       ($0101010101010101,
        $0202020202020202,
        $0404040404040404,
        $0808080808080808,
        $1010101010101010,
        $2020202020202020,
        $4040404040404040,
        $8080808080808080);


    ConnectedWhitePawn : array[0..47] of UInt64 =
     ($0000000000020200, $0000000000050500, $00000000000A0A00, $0000000000141400, $0000000000282800, $0000000000505000, $0000000000A0A000, $0000000000404000,
      $0000000002020000, $0000000005050000, $000000000A0A0000, $0000000014140000, $0000000028280000, $0000000050500000, $00000000A0A00000, $0000000040400000,
      $0000000202000000, $0000000505000000, $0000000A0A000000, $0000001414000000, $0000002828000000, $0000005050000000, $000000A0A0000000, $0000004040000000,
      $0000020200000000, $0000050500000000, $00000A0A00000000, $0000141400000000, $0000282800000000, $0000505000000000, $0000A0A000000000, $0000404000000000,
      $0002020000000000, $0005050000000000, $000A0A0000000000, $0014140000000000, $0028280000000000, $0050500000000000, $00A0A00000000000, $0040400000000000,
      $0002000000000000, $0005000000000000, $000A000000000000, $0014000000000000, $0028000000000000, $0050000000000000, $00A0000000000000, $0040000000000000);

    ConnectedBlackPawn : array[0..47] of UInt64 =
     ($0000000000000200, $0000000000000500, $0000000000000A00, $0000000000001400, $0000000000002800, $0000000000005000, $000000000000A000, $0000000000004000,
      $0000000000020200, $0000000000050500, $00000000000A0A00, $0000000000141400, $0000000000282800, $0000000000505000, $0000000000A0A000, $0000000000404000,
      $0000000002020000, $0000000005050000, $000000000A0A0000, $0000000014140000, $0000000028280000, $0000000050500000, $00000000A0A00000, $0000000040400000,
      $0000000202000000, $0000000505000000, $0000000A0A000000, $0000001414000000, $0000002828000000, $0000005050000000, $000000A0A0000000, $0000004040000000,
      $0000020200000000, $0000050500000000, $00000A0A00000000, $0000141400000000, $0000282800000000, $0000505000000000, $0000A0A000000000, $0000404000000000,
      $0002020000000000, $0005050000000000, $000A0A0000000000, $0014140000000000, $0028280000000000, $0050500000000000, $00A0A00000000000, $0040400000000000);


    BackwardWhitePawn : array[0..47] of UInt64 =
     ($0002020202020200, $0005050505050500, $000A0A0A0A0A0A00, $0014141414141400, $0028282828282800, $0050505050505000, $00A0A0A0A0A0A000, $0040404040404000,
      $0002020202020000, $0005050505050000, $000A0A0A0A0A0000, $0014141414140000, $0028282828280000, $0050505050500000, $00A0A0A0A0A00000, $0040404040400000,
      $0002020202000000, $0005050505000000, $000A0A0A0A000000, $0014141414000000, $0028282828000000, $0050505050000000, $00A0A0A0A0000000, $0040404040000000,
      $0002020200000000, $0005050500000000, $000A0A0A00000000, $0014141400000000, $0028282800000000, $0050505000000000, $00A0A0A000000000, $0040404000000000,
      $0002020000000000, $0005050000000000, $000A0A0000000000, $0014140000000000, $0028280000000000, $0050500000000000, $00A0A00000000000, $0040400000000000,
      $0002000000000000, $0005000000000000, $000A000000000000, $0014000000000000, $0028000000000000, $0050000000000000, $00A0000000000000, $0040000000000000);

    BackwardBlackPawn : array[0..47] of UInt64 =
     ($0000000000000200, $0000000000000500, $0000000000000A00, $0000000000001400, $0000000000002800, $0000000000005000, $000000000000A000, $0000000000004000,
      $0000000000020200, $0000000000050500, $00000000000A0A00, $0000000000141400, $0000000000282800, $0000000000505000, $0000000000A0A000, $0000000000404000,
      $0000000002020200, $0000000005050500, $000000000A0A0A00, $0000000014141400, $0000000028282800, $0000000050505000, $00000000A0A0A000, $0000000040404000,
      $0000000202020200, $0000000505050500, $0000000A0A0A0A00, $0000001414141400, $0000002828282800, $0000005050505000, $000000A0A0A0A000, $0000004040404000,
      $0000020202020200, $0000050505050500, $00000A0A0A0A0A00, $0000141414141400, $0000282828282800, $0000505050505000, $0000A0A0A0A0A000, $0000404040404000,
      $0002020202020200, $0005050505050500, $000A0A0A0A0A0A00, $0014141414141400, $0028282828282800, $0050505050505000, $00A0A0A0A0A0A000, $0040404040404000);

    WhiteSupportedPawn : array[0..47] of UInt64 =
     ($0000000000020000, $0000000000050000, $00000000000A0000, $0000000000140000, $0000000000280000, $0000000000500000, $0000000000A00000, $0000000000400000,
      $0000000002000000, $0000000005000000, $000000000A000000, $0000000014000000, $0000000028000000, $0000000050000000, $00000000A0000000, $0000000040000000,
      $0000000200000000, $0000000500000000, $0000000A00000000, $0000001400000000, $0000002800000000, $0000005000000000, $000000A000000000, $0000004000000000,
      $0000020000000000, $0000050000000000, $00000A0000000000, $0000140000000000, $0000280000000000, $0000500000000000, $0000A00000000000, $0000400000000000,
      $0002000000000000, $0005000000000000, $000A000000000000, $0014000000000000, $0028000000000000, $0050000000000000, $00A0000000000000, $0040000000000000,
      $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000);

    BlackSupportedPawn : array[0..47] of UInt64 =
     ($0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000,
      $0000000000000200, $0000000000000500, $0000000000000A00, $0000000000001400, $0000000000002800, $0000000000005000, $000000000000A000, $0000000000004000,
      $0000000000020000, $0000000000050000, $00000000000A0000, $0000000000140000, $0000000000280000, $0000000000500000, $0000000000A00000, $0000000000400000,
      $0000000002000000, $0000000005000000, $000000000A000000, $0000000014000000, $0000000028000000, $0000000050000000, $00000000A0000000, $0000000040000000,
      $0000000200000000, $0000000500000000, $0000000A00000000, $0000001400000000, $0000002800000000, $0000005000000000, $000000A000000000, $0000004000000000,
      $0000020000000000, $0000050000000000, $00000A0000000000, $0000140000000000, $0000280000000000, $0000500000000000, $0000A00000000000, $0000400000000000);


    WhiteKeySqrMask : array[0..63] of UInt64 =
     ($0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000,
      $0000000000000000, $0000000000000507, $0000000000000A0E, $000000000000141C, $0000000000002838, $0000000000005070, $000000000000A0E0, $0000000000000000,
      $0000000000000000, $0000000000000707, $0000000000000E0E, $0000000000001C1C, $0000000000003838, $0000000000007070, $000000000000E0E0, $0000000000000000,
      $0000000000000202, $0000000000070700, $00000000000E0E00, $00000000001C1C00, $0000000000383800, $0000000000707000, $0000000000E0E000, $0000000000004040,
      $0000000000000202, $0000000000070000, $00000000000E0000, $00000000001C0000, $0000000000380000, $0000000000700000, $0000000000E00000, $0000000000004040,
      $0000000000000202, $0000000007000000, $000000000E000000, $000000001C000000, $0000000038000000, $0000000070000000, $00000000E0000000, $0000000000004040,
      $0000000000000202, $0000000700000000, $0000000E00000000, $0000001C00000000, $0000003800000000, $0000007000000000, $000000E000000000, $0000000000004040,
      $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000);

    BlackKeySqrMask : array[0..63] of UInt64 =
     ($0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000,
      $0202000000000000, $0000000007000000, $000000000E000000, $000000001C000000, $0000000038000000, $0000000070000000, $00000000E0000000, $4040000000000000,
      $0202000000000000, $0000000700000000, $0000000E00000000, $0000001C00000000, $0000003800000000, $0000007000000000, $000000E000000000, $4040000000000000,
      $0202000000000000, $0000070000000000, $00000E0000000000, $00001C0000000000, $0000380000000000, $0000700000000000, $0000E00000000000, $4040000000000000,
      $0202000000000000, $0007070000000000, $000E0E0000000000, $001C1C0000000000, $0038380000000000, $0070700000000000, $00E0E00000000000, $4040000000000000,
      $0000000000000000, $0707000000000000, $0E0E000000000000, $1C1C000000000000, $3838000000000000, $7070000000000000, $E0E0000000000000, $0000000000000000,
      $0000000000000000, $0705000000000000, $0E0A000000000000, $1C14000000000000, $3828000000000000, $7050000000000000, $E0A0000000000000, $0000000000000000,
      $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000, $0000000000000000);



    KingPrecinctIndex : array[0..63] of integer =

        ( 0,  1,  1,  1,  1,  1,  1,  0,
          1,  2,  2,  2,  2,  2,  2,  1,
          1,  2,  2,  2,  2,  2,  2,  1,
          1,  2,  2,  2,  2,  2,  2,  1,
          1,  2,  2,  2,  2,  2,  2,  1,
          1,  2,  2,  2,  2,  2,  2,  1,
          1,  2,  2,  2,  2,  2,  2,  1,
          0,  1,  1,  1,  1,  1,  1,  0);


    KingRegionIndex : array[0..63] of integer =

        ( 2,  2,  2,  2,  2,  2,  2,  2,
          2,  2,  2,  2,  2,  2,  2,  2,
          2,  2,  2,  2,  2,  2,  2,  2,
          2,  2,  2,  2,  2,  2,  2,  2,
          2,  2,  2,  2,  2,  2,  2,  2,
          2,  2,  2,  2,  2,  2,  2,  2,
          1,  1,  2,  2,  2,  2,  0,  0,
          1,  1,  1,  1,  0,  0,  0,  0);


// =============================================================================


   Material_Table : array[0..53, 0..8] of integer =

  ((     0,      70,     148,     218,     278,     344,     411,     477,     444),  //  [Q=0, R=0, B=0, N=0]
  (    384,     432,     503,     579,     660,     755,     867,     990,    1125),  //  [Q=0, R=0, B=0, N=1]
  (    373,     701,     845,     957,    1075,    1195,    1363,    1554,    1779),  //  [Q=0, R=0, B=0, N=2]
  (    440,     454,     507,     571,     638,     721,     819,     935,    1067),  //  [Q=0, R=0, B=1, N=0]
  (    506,     757,     860,     963,    1070,    1194,    1345,    1518,    1706),  //  [Q=0, R=0, B=1, N=1]
  (    795,    1051,    1192,    1332,    1484,    1624,    1817,    2078,    2214),  //  [Q=0, R=0, B=1, N=2]
  (    539,     795,     928,    1044,    1163,    1290,    1427,    1571,    1741),  //  [Q=0, R=0, B=2, N=0]
  (    873,    1079,    1245,    1395,    1554,    1702,    1885,    2122,    2345),  //  [Q=0, R=0, B=2, N=1]
  (   1430,    1435,    1535,    1743,    1920,    2120,    2319,    2583,    2503),  //  [Q=0, R=0, B=2, N=2]
  (    634,     711,     771,     855,     940,    1037,    1144,    1259,    1334),  //  [Q=0, R=1, B=0, N=0]
  (    716,     968,    1101,    1217,    1337,    1472,    1631,    1798,    1952),  //  [Q=0, R=1, B=0, N=1]
  (   1051,    1291,    1427,    1574,    1733,    1894,    2094,    2287,    2500),  //  [Q=0, R=1, B=0, N=2]
  (    714,     967,    1092,    1213,    1336,    1465,    1610,    1764,    1916),  //  [Q=0, R=1, B=1, N=0]
  (   1019,    1256,    1422,    1570,    1720,    1887,    2079,    2289,    2515),  //  [Q=0, R=1, B=1, N=1]
  (   1380,    1574,    1719,    1892,    2076,    2283,    2514,    2764,    3053),  //  [Q=0, R=1, B=1, N=2]
  (   1051,    1304,    1479,    1640,    1800,    1965,    2155,    2370,    2592),  //  [Q=0, R=1, B=2, N=0]
  (   1385,    1581,    1788,    1955,    2152,    2360,    2594,    2853,    3122),  //  [Q=0, R=1, B=2, N=1]
  (   2261,    1833,    2034,    2219,    2460,    2711,    2993,    3294,    3686),  //  [Q=0, R=1, B=2, N=2]
  (   1061,    1214,    1345,    1474,    1601,    1735,    1881,    2033,    2205),  //  [Q=0, R=2, B=0, N=0]
  (   1299,    1509,    1666,    1821,    1983,    2164,    2361,    2570,    2772),  //  [Q=0, R=2, B=0, N=1]
  (   1652,    1759,    1952,    2133,    2329,    2543,    2788,    3038,    3291),  //  [Q=0, R=2, B=0, N=2]
  (   1266,    1491,    1649,    1811,    1974,    2149,    2337,    2536,    2728),  //  [Q=0, R=2, B=1, N=0]
  (   1515,    1741,    1940,    2122,    2320,    2536,    2776,    3030,    3282),  //  [Q=0, R=2, B=1, N=1]
  (   2091,    2023,    2189,    2401,    2633,    2891,    3181,    3481,    3806),  //  [Q=0, R=2, B=1, N=2]
  (   1688,    1818,    1997,    2205,    2395,    2611,    2843,    3096,    3340),  //  [Q=0, R=2, B=2, N=0]
  (   2075,    1945,    2249,    2470,    2702,    2962,    3249,    3555,    3863),  //  [Q=0, R=2, B=2, N=1]
  (   2591,    2436,    2430,    2731,    2992,    3299,    3642,    3983,    4329),  //  [Q=0, R=2, B=2, N=2]
  (    940,    1074,    1215,    1346,    1488,    1636,    1794,    1945,    2143),  //  [Q=1, R=0, B=0, N=0]
  (   1144,    1451,    1614,    1766,    1935,    2103,    2294,    2494,    2752),  //  [Q=1, R=0, B=0, N=1]
  (   1572,    1756,    1930,    2119,    2321,    2512,    2721,    2960,    3145),  //  [Q=1, R=0, B=0, N=2]
  (   1203,    1453,    1624,    1789,    1954,    2120,    2297,    2483,    2630),  //  [Q=1, R=0, B=1, N=0]
  (   1512,    1766,    1950,    2140,    2323,    2523,    2740,    2984,    3210),  //  [Q=1, R=0, B=1, N=1]
  (   1961,    1944,    2182,    2404,    2651,    2860,    3137,    3415,    3592),  //  [Q=1, R=0, B=1, N=2]
  (   1605,    1868,    2035,    2221,    2405,    2608,    2815,    3058,    3248),  //  [Q=1, R=0, B=2, N=0]
  (   2171,    2141,    2293,    2488,    2708,    2947,    3219,    3517,    3669),  //  [Q=1, R=0, B=2, N=1]
  (   2725,    2577,    2541,    2749,    2980,    3267,    3560,    3899,    3849),  //  [Q=1, R=0, B=2, N=2]
  (   1534,    1682,    1852,    2009,    2175,    2344,    2528,    2718,    2929),  //  [Q=1, R=1, B=0, N=0]
  (   1763,    1927,    2126,    2314,    2513,    2719,    2951,    3196,    3431),  //  [Q=1, R=1, B=0, N=1]
  (   2186,    2128,    2340,    2579,    2814,    3066,    3346,    3634,    3909),  //  [Q=1, R=1, B=0, N=2]
  (   1756,    1941,    2140,    2331,    2534,    2740,    2961,    3202,    3431),  //  [Q=1, R=1, B=1, N=0]
  (   1928,    2143,    2378,    2592,    2832,    3085,    3358,    3643,    3957),  //  [Q=1, R=1, B=1, N=1]
  (   2436,    2313,    2552,    2833,    3108,    3407,    3720,    4048,    4348),  //  [Q=1, R=1, B=1, N=2]
  (   2089,    2241,    2436,    2678,    2916,    3174,    3445,    3730,    4002),  //  [Q=1, R=1, B=2, N=0]
  (   2365,    2413,    2626,    2896,    3191,    3485,    3798,    4132,    4461),  //  [Q=1, R=1, B=2, N=1]
  (   3091,    2766,    2772,    3120,    3432,    3782,    4142,    4519,    4925),  //  [Q=1, R=1, B=2, N=2]
  (   1904,    2120,    2323,    2544,    2757,    2976,    3202,    3428,    3655),  //  [Q=1, R=2, B=0, N=0]
  (   2091,    2324,    2538,    2805,    3060,    3327,    3601,    3889,    4174),  //  [Q=1, R=2, B=0, N=1]
  (   2694,    2609,    2769,    3037,    3328,    3637,    3954,    4282,    4607),  //  [Q=1, R=2, B=0, N=2]
  (   2077,    2356,    2582,    2825,    3076,    3338,    3609,    3889,    4170),  //  [Q=1, R=2, B=1, N=0]
  (   2374,    2480,    2786,    3055,    3343,    3648,    3969,    4299,    4629),  //  [Q=1, R=2, B=1, N=1]
  (   2919,    2586,    2924,    3252,    3601,    3942,    4311,    4693,    5082),  //  [Q=1, R=2, B=1, N=2]
  (   2764,    2577,    2840,    3132,    3431,    3739,    4051,    4377,    4704),  //  [Q=1, R=2, B=2, N=0]
  (   3095,    2796,    2989,    3319,    3670,    4021,    4387,    4767,    5158),  //  [Q=1, R=2, B=2, N=1]
  (   3294,    2799,    3086,    3527,    3892,    4311,    4735,    5176,    5602));  //  [Q=1, R=2, B=2, N=2]


  ThirdKnightValue = 413;
  ThirdBishopValue = 316;
  ThirdRookValue = 350;
  SecondQueenValue = 679;

  PST_Table_Pawn_mg : array[0..2, 0..63] of integer =

  ((      0,      0,      0,      0,      0,      0,      0,      0,
         14,    -51,    -39,    -18,     17,    -20,    -79,   -100,
        -16,    -14,     11,     47,     87,    140,    152,     67,
        -13,    -20,    -12,     15,     30,     48,     22,     35,
        -37,    -41,    -20,     -9,     -7,     11,      3,     -1,
        -50,    -54,    -51,    -46,    -41,    -14,     13,     -2,
        -46,    -41,    -37,    -10,    -24,     27,     53,     13,
          0,      0,      0,      0,      0,      0,      0,      0),

   (      0,      0,      0,      0,      0,      0,      0,      0,
         55,    -30,    -19,     13,      0,    -33,    -66,   -125,
         -4,      7,     11,     67,     74,    101,    129,      0,
         56,     23,     25,     23,     10,     13,    -35,    -51,
         60,      9,     20,      2,    -16,    -31,    -72,    -95,
         48,     38,    -17,    -54,    -40,    -54,    -95,   -121,
         51,     67,     27,      3,    -38,    -34,    -70,   -106,
          0,      0,      0,      0,      0,      0,      0,      0),

   (      0,      0,      0,      0,      0,      0,      0,      0,
         41,    -36,     -3,     10,     11,    -18,    -75,    -95,
        -14,     -8,      2,     54,     81,    123,    152,     66,
         -6,    -21,      7,     11,     49,     47,     30,     26,
        -38,    -44,    -13,      8,     22,     17,     -2,    -29,
        -57,    -43,    -26,    -37,    -16,      9,    -22,    -52,
        -66,    -38,     -2,    -14,     -7,     10,     -1,    -51,
          0,      0,      0,      0,      0,      0,      0,      0));


  PST_Table_Pawn_eg : array[0..2, 0..63] of integer =

  ((      0,      0,      0,      0,      0,      0,      0,      0,
        149,    159,    179,    116,    107,    159,    187,    158,
        223,    217,    198,    187,    182,    202,    238,    244,
        139,    124,    117,     86,     90,     86,    125,    118,
         92,     92,     80,     72,     83,     78,     79,     75,
         76,     83,     86,     88,     92,     89,     65,     59,
         88,     96,    110,     63,    128,    115,     87,     53,
          0,      0,      0,      0,      0,      0,      0,      0),

   (      0,      0,      0,      0,      0,      0,      0,      0,
        130,    171,    187,    143,    119,    158,    188,    139,
        228,    217,    214,    196,    197,    211,    216,    224,
        131,    122,    110,     91,    106,    101,    137,    133,
         80,     94,     84,     69,     91,     89,     97,     90,
         61,     70,     88,     88,     75,     88,     94,     86,
         48,     78,    105,     74,    111,    126,    126,    116,
          0,      0,      0,      0,      0,      0,      0,      0),

   (      0,      0,      0,      0,      0,      0,      0,      0,
        122,    147,    190,    149,    146,    180,    209,    145,
        222,    215,    229,    218,    216,    227,    242,    234,
        153,    147,    134,    127,    123,    118,    138,    134,
        118,    115,    102,     87,     95,     93,     95,     94,
         99,     96,     86,     86,     81,     81,     83,     82,
        113,    112,    102,     93,    106,    113,    106,    104,
          0,      0,      0,      0,      0,      0,      0,      0));


  PST_Table_mg : array[knight..king, 0..63] of integer =

  ((   -164,    -64,    -33,     21,     97,    -33,     -6,   -122,
        -29,    -31,     38,     73,     57,    124,     39,     24,
          1,     24,     41,     87,    127,    163,     96,     69,
         21,     17,     29,     69,     55,     65,     48,     75,
         14,     19,     17,     16,     17,     35,     42,     21,
        -20,    -24,    -17,      3,      4,    -13,    -10,     -8,
        -45,    -30,    -22,    -23,     -7,    -28,    -25,    -23,
        -84,     -7,    -58,    -29,    -17,    -46,    -31,    -76),

   (     28,    -27,    -43,    -59,     -6,    -88,      7,      5,
        -42,    -15,      0,     -3,      2,    -10,    -25,    -77,
         -8,     38,     23,     60,     66,    150,    107,     64,
        -14,    -22,     32,     45,     38,     54,      9,     -5,
         -4,     16,      2,     35,     27,      1,     -5,     38,
         26,     18,     14,      7,      5,     -6,      7,     14,
         35,     26,     27,     -2,     -4,     13,     31,     29,
         25,     52,     20,    -28,      0,    -14,     23,    -12),

   (     55,     39,     65,     51,     68,     55,     61,    126,
         22,      8,     56,    106,     92,    108,     78,    114,
          2,     56,     36,     43,    105,    156,    154,    123,
        -20,     -2,      5,     33,     15,     62,    100,     73,
        -33,    -21,    -13,     -3,      2,      1,     56,     28,
        -29,    -20,    -16,     -7,      8,     17,     65,     47,
        -35,    -26,    -15,     -8,      1,     16,     40,     -1,
        -21,    -13,    -14,      0,      9,      0,     24,      4),

   (      8,     29,     18,     14,     28,     56,     86,     72,
         28,    -19,      5,     13,    -26,     27,     27,    130,
         31,     43,     19,     23,     43,    121,    100,     59,
         33,     18,     29,     23,     24,     54,     86,     79,
         35,     34,     33,     26,     40,     49,     78,     89,
         49,     53,     43,     41,     49,     59,     86,     94,
         38,     52,     61,     64,     64,     72,     89,    115,
         38,     55,     46,     50,     67,     29,     45,     53),

   (    246,    133,     88,     30,     44,     32,     17,     80,
        102,     62,     76,     43,     66,     12,    -29,      5,
         92,     77,     19,     22,    -35,      5,     -4,     25,
         59,     28,      8,    -39,    -75,    -79,    -77,   -107,
         30,     24,    -27,    -78,    -91,   -109,   -134,   -158,
         60,     -2,    -36,    -79,    -93,    -90,    -68,    -47,
         98,     23,    -15,    -57,    -56,    -38,     21,     47,
         71,     63,     35,    -64,      5,    -62,     53,     93));


  PST_Table_eg : array[knight..king, 0..63] of integer =

  ((     20,     30,     44,     34,     12,     27,     48,      4,
         19,     37,      9,     32,     20,    -18,     23,     -1,
         15,     20,     27,     23,     -3,     -3,      5,      6,
         36,     28,     39,     40,     42,     34,     35,     29,
         33,     26,     38,     43,     47,     32,     33,     33,
          3,     16,     14,     27,     23,     -2,      1,     14,
         21,     28,      2,      7,      2,     11,     26,     10,
         16,    -36,     10,     21,     -2,     -2,    -22,     33),

   (     41,     55,     50,     52,     27,     48,     40,     40,
         43,     38,     39,     32,     34,     34,     40,     23,
         37,     31,     30,     24,     16,     17,     -1,     18,
         37,     50,     29,     42,     45,     16,     42,     21,
         20,     25,     45,     44,     34,     34,     19,     -2,
         19,     25,     39,     31,     42,     22,      0,      7,
         37,      7,      9,     26,     20,      7,     -4,     -9,
         21,      5,      4,     32,     19,     16,     -6,     15),

   (     58,     72,     67,     63,     61,     70,     58,     41,
         73,     82,     67,     52,     48,     42,     41,     30,
         87,     67,     69,     68,     38,     34,     27,     33,
         89,     78,     78,     66,     70,     61,     33,     41,
         84,     76,     76,     68,     66,     70,     32,     45,
         78,     64,     65,     62,     55,     52,     15,     30,
         73,     58,     66,     59,     52,     38,     16,     33,
         75,     58,     71,     59,     47,     59,     28,     35),

   (     55,     43,     54,     70,     58,     45,     31,     46,
         42,     94,     94,     97,    134,     80,     74,      6,
         53,     71,    108,    116,    110,     54,     20,     26,
         58,    106,    117,    137,    130,    103,     70,     60,
         70,     84,    103,    138,    112,    108,     52,     57,
         39,     51,     84,     82,     86,     83,     28,     -2,
         36,     38,     28,     44,     44,     -6,    -57,    -45,
         20,     -1,     26,     28,     -6,    -12,    -42,     16),

   (    -81,    -38,    -21,    -12,    -19,    -19,    -21,    -73,
        -58,     -8,      1,     10,      1,     23,     26,    -32,
        -42,     -8,     22,     22,     30,     23,     21,    -29,
        -44,     -7,     23,     46,     45,     35,     10,    -10,
        -53,    -18,     14,     39,     38,     24,     10,    -10,
        -54,    -22,      8,     24,     25,     11,     -7,    -24,
        -41,      5,     -4,     11,      7,     -5,      8,    -20,
         28,    -34,    -15,     10,    -12,     15,    -31,    -12));


  Knight_Mobility : array[0..8] of integer =
    (    -52,      0,     28,     45,     59,     74,     85,     93,     88);

  Bishop_Mobility : array[0..13] of integer =
    (     -6,     31,     52,     64,     78,     90,     99,    106,    110,    113,    114,    107,    116,     85);

  Rook_Mobility : array[0..14] of integer =
    (    -51,     63,     88,     95,    104,    108,    116,    123,    129,    135,    140,    145,    149,    145,    135);

  Queen_Mobility : array[0..27] of integer =
    (    -46,    138,    143,    148,    159,    161,    165,    170,    176,    181,    186,    191,    197,    201,    206,    208,    210,    213,    215,    213,    207,    206,    194,    176,    163,    146,    139,    126);

  AttackBonus_STM : array[pawn..queen, pawn..queen] of integer =

  ((   0,  55,  50,  54,  37),
   (   0, -15,  50,  66,  54),
   (   0,  44, -19, 107,  29),
   (   0,  20,  30, -19,  48),
   (   0,   1,  11,   3, -29));

  AttackBonus_OTM : array[pawn..queen, pawn..queen] of integer =

  ((   0,  82,  83,  70,  81),
   (   0,   0,  52,  54,  53),
   (   0,  39,   0,  59, 113),
   (   0,  23,  30,   0, 110),
   (   0,   4,  10,   5,   0));


  MultiAttackBonus_STM : array[knight..queen, 0..8] of integer =

  ((   1,   1,  -9, -30,   0,   0,   0,   0,   0),
   (   0,   1, -26,  -6,   0,   0,   0,   0,   0),
   (   0,   1, -16, -38,   0,   0,   0,   0,   0),
   (   0,   3,  -4, -24, -13,   0,   0,   0,   0));

  MultiAttackBonus_OTM : array[knight..queen, 0..8] of integer =

  ((   0,  -1,  17, -22,   0,   0,   0,   0,   0),
   (   0,   0,  -4,  -6,   0,   0,   0,   0,   0),
   (   0,   1,  -6, -29,   0,   0,   0,   0,   0),
   (   0,   1,   1, -11, -15,   0,   0,   0,   0));



  DefendedByBonus : array[pawn..queen] of integer =
    (   4,  3,  6,  7,  6);                                 // rook & queen values are used in mg, eg values = 0

  AttackBonus_King_Pawn = 65;

  AttackBonus_Knight_King_Threat = 12;
  AttackBonus_Bishop_King_Threat = 23;
  AttackBonus_Rook_King_Threat = 18;

  AttackBonus_Queen_King_Threat_STM = 25;
  AttackBonus_Queen_King_Threat_OTM = 16;
  AttackBonus_KnightFork = 97;
  AttackBonus_BishopFork = 93;
  PinnedQueen_Penalty_STM = -15;
  PinnedQueen_Penalty_OTM = 108;
  PinnedRook_Penalty = 32;
  PinnedBishop_Penalty = 32;
  PinnedKnight_Penalty = 18;
  Tempo_Bonus_mg = 39;
  Tempo_Bonus_eg = 15;
  RookOnOpenFile_Bonus_mg = 43;
  RookOnOpenFile_Bonus_eg = 1;
  RookOnSemiOpenFile_Bonus_mg = 12;
  RookOnSemiOpenFile_Bonus_eg = 33;
  BishopPawn_Penalty = -8;
  BishopCentreControl_Bonus = 7;
  KingKnightDist_Penalty = -7;
  KingBishopDist_Penalty = -4;

  QP_ImBalFactor = -43;
  QN_ImBalFactor = -3;
  QB_ImBalFactor = -17;
  QR_ImBalFactor = -33;
  RP_ImBalFactor = -16;
  RN_ImBalFactor = 21;
  RB_ImBalFactor = 27;
  BP_ImBalFactor = -21;
  BN_ImBalFactor = 8;
  NP_ImBalFactor = -17;

  KingAttackPawnsOnly = 67;
  KingOnOpenFile_Penalty_mg = -49;
  KingOnOpenFile_Penalty_eg = -17;
  KingOnSemiOpenFile_Penalty_mg = -26;
  KingOnSemiOpenFile_Penalty_eg = 29;

  KingExposure_Penalty_mg : array[0..2, 0..27] of integer =

  ((   8,  33,  25,   4,  -3,   2,   2,  -2, -13, -44, -54, -32, -48, -61, -51,-262, -66,   2,   3,   0,  11,  37,   0,   0,   0,   0,   0,   0),
   (  11,   6,  -2,  -5,  -4,   0,   4,   3,  -2,   0,  -3,  -8,  -9, -10, -28, -23, -31,  -4,  18,  48,  73,  91,   0,   0,   0,   0,   0,   0),
   (  -1,  -4,  -5,  -1,  10,  14,   2,   0,   5,  -2,  -3, -14, -14, -12, -15, -19, -12, -10, -13, -11,   4,  -2,   7,  22,  -3,  18,   0,   0));

  KingExposure_Penalty_eg : array[0..2, 0..27] of integer =

  (( -33, -48, -39, -25, -16, -20, -16, -57, -10,  14,  33,  26,  24,  39,  29, 190, 111,  47,  46,  18,  59,  20,   0,   0,   0,   0,   0,   0),
   ( -85,   9,  -1, -11,  -9, -11, -13, -18,  -5,  -1,   3,  11,  13,  13,  21,  26,  36,  16,  -1, -12, -10, -12,   0,   0,   0,   0,   0,   0),
   (  -1,  -4,  -4,  -2, -11, -14,  -6,  -7, -10,  -6,  -6,   0,   5,   5,   6,   9,   8,   9,   8,   6,  -2,  -4,  -7, -15, -19, -24, -30, -34));

  KingAdjExposure_Penalty_mg : array[0..2, 0..27] of integer =

  ((  -7, -13,  -3,   2,  -1,   6,   4,   1,   2,  11,  13,  10,   4,   0,   0,  -4,  -1,  -1, -10,  -2,  -5,   0,   0,   0,   0,   0,   0,   0),
   (   5,   3,  -1,  -1,  -5,  -1,  -3,  -5,  -5,  -6,  -8,  -7,  -6,  -9,  -8,   0,  -4,  -7,  -6,  -1,   6,   9,  16,   0,   0,   0,   0,   0),
   ( -15, -28,  -6,  10,   3,   1,   0,   2,   4,   4,   0,   2,   0,  -3,   1,   0,  -1,  -1,  -1,   1,   3,  -5,   9,   6,   1,   0,   0,   0));

  KingAdjExposure_Penalty_eg : array[0..2, 0..27] of integer =

  ((   1,   2,   0,  -6, -14,  -1, -11,  -4,  -6, -12,   2,  -2,  -4,   0,   0,  19,  -1,  -1,  -3,  -9,  54,   0,   0,   0,   0,   0,   0,   0),
   (  -6,   4,   5,   1,   6,   1,   2,   2,   3,   4,   4,   4,   2,   2,  -2,  -7,  -5,  -7, -12,  -8, -20, -33, -47,   0,   0,   0,   0,   0),
   (   0,  -4, -12,  -9,   3,   1,   1,   0,  -4,   0,   2,   0,   3,   3,   0,   2,   4,  -1,  -1,  -4,  -8,  -7, -14, -19,   1,   0,   0,   0));


  KingAttack_STM : array[0..2, 0..4, 0..12] of integer =

  (((    24,    44,    76,   150,   166,   292,    12,     0,     0,     0,     0,     0,     0),
    (    18,    27,    53,   126,   149,   203,   274,     0,     0,     0,     0,     0,     0),
    (    37,    23,    38,    60,  -116,   152,     0,     0,     0,     0,     0,     0,     0),
    (     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0),
    (     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0)),

   ((   -18,   -26,   -15,    -8,    21,    58,   191,   264,   285,   319,   365,   355,     0),
    (   -24,   -33,   -25,    -4,    39,   104,   189,   276,   325,   342,     0,     0,     0),
    (   -29,   -45,   -44,   -23,     6,    62,   234,    74,   233,   206,     0,     0,     0),
    (   -22,   -46,   -62,   -65,   -45,   -16,   178,     0,     0,     0,     0,     0,     0),
    (     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0)),

   ((    15,   -22,   -18,   -24,   -42,   -51,   -27,     7,    85,   218,   283,   366,   -79),
    (   -34,   -46,   -39,   -46,   -44,   -36,   -17,    27,    91,   174,   283,   138,    70),
    (   -35,   -50,   -52,   -56,   -49,   -38,    -9,    37,    66,    75,   290,   -27,   215),
    (   -37,   -53,   -64,   -74,   -72,   -63,   -24,    52,   124,    41,    61,     0,     0),
    (   -53,   -75,   -88,   -74,  -161,  -116,  -147,     0,     0,     0,     0,     0,     0)));


  KingAttack_OTM : array[0..2, 0..4, 0..12] of integer =

  (((    26,    32,    43,    61,   117,   131,   -10,     0,     0,     0,     0,     0,     0),
    (    19,    23,    36,    93,   189,   249,   338,     0,     0,     0,     0,     0,     0),
    (    28,     2,    14,   108,   136,   146,     0,     0,     0,     0,     0,     0,     0),
    (     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0),
    (     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0)),

   ((   -18,   -35,   -25,   -10,    -4,    18,   123,   145,   235,   283,   385,   375,     0),
    (   -25,   -39,   -32,   -13,    22,    92,   173,   192,   284,   363,     0,     0,     0),
    (   -30,   -51,   -47,   -29,     3,    76,   121,    90,   244,   211,     0,     0,     0),
    (   -28,   -56,   -74,   -63,   -33,    41,   194,     0,     0,     0,     0,     0,     0),
    (     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0)),

   ((    20,   -25,   -15,   -21,   -41,   -43,   -42,   -37,    -2,   -32,   116,   262,  -114),
    (   -27,   -42,   -34,   -42,   -40,   -31,   -24,   -13,    41,    79,    48,   100,    20),
    (   -26,   -40,   -42,   -47,   -44,   -35,   -34,     0,    16,   113,   165,     0,   225),
    (   -29,   -45,   -56,   -60,   -64,   -51,   -46,    17,    89,    12,    67,     0,     0),
    (   -36,   -80,   -82,   -65,  -109,   -60,  -155,     0,     0,     0,     0,     0,     0)));


    PassedPawn_Table : array[0..63] of integer =

  (      0,      0,      0,      0,      0,      0,      0,      0,
       232,    243,    226,    240,    241,    219,    195,    212,
       104,    106,     85,     53,     50,     44,     33,     36,
        61,     67,     44,     36,     33,     49,     56,     44,
        37,     37,     13,      6,      6,     15,     37,     31,
         6,      3,     -9,    -17,    -12,    -12,     -2,      2,
        -2,     -2,    -19,    -22,    -12,    -32,    -12,     -3,
         0,      0,      0,      0,      0,      0,      0,      0);


  ConnectedPawn_Table : array[0..63] of integer =

  (      0,      0,      0,      0,      0,      0,      0,      0,
       102,    122,    125,    169,    135,     83,     91,     36,
        55,     62,     71,     92,     87,     71,     41,     32,
        13,     16,     32,     24,     33,     37,     24,     14,
         3,     14,     16,     19,     19,     20,     17,     14,
         8,     16,     26,     25,     30,     17,     17,     14,
         6,      9,      1,      4,     19,    -10,      8,     -5,
         0,      0,      0,      0,      0,      0,      0,      0);


  IsolatedPawnPenalty_mg = -11;
  IsolatedPawnPenalty_eg = -7;
  DoubledPawnPenalty_mg = -8;
  DoubledPawnPenalty_eg = -18;
  BackwardPawnPenalty_mg = -11;
  BackwardPawnPenalty_eg = -6;
  PawnWidthBonus_mg = -6;
  PawnWidthBonus_eg = 10;
  BlockedOnRank6Penalty_mg = -25;
  BlockedOnRank6Penalty_eg = -35;
  BlockedOnRank7Penalty_mg = -6;
  BlockedOnRank7Penalty_eg = -108;

  PasserCanAdvanceBonusA_eg = 23;
  PasserBlockedPenaltyA_eg = -27;
  PasserCanAdvanceBonusB_eg = -1;
  PasserBlockedPenaltyB_eg = -19;

  UnstoppableBonus_eg : array[0..6] of integer =
    (   0, 899, 705, 415, 204,  20,  78);

  KingProximityBonusA_eg : array[-7..7] of integer =
    (  40, 156, 159, 117, 116, 134, 124, 126, 107,  69,  24, -31, -66,-109,-131);

  KingProximityBonusB_eg : array[-6..6] of integer =
    (  82,  60,  56,  44,  39,  18,  10,  -6, -20, -33, -50, -88, -56);

  KingEscortBonus_eg = 921;


// ============================================================================


function Distance(Cell1, Cell2 : integer) : integer;
function FileMask(Cell : integer) : UInt64;
function RankMask(Cell : integer) : UInt64;
function RanksBelowMask(rank : integer) : UInt64;
function RanksAboveMask(rank : integer) : UInt64;

function ScoreFromBoard(const Board : TBoard) : integer;
function EvalCalc(const Board : TBoard; Passers : UInt64) : integer;
function PawnBonus(const Board : TBoard; var Passers : UInt64) : integer;

function IsPassedPawn(const Board : TBoard; Player, Cell : integer) : boolean;
function IsIsolatedPawn(const Board : TBoard; Player, Cell : integer) : boolean;
function IsBlockedPawn(const Board : TBoard; Player, Cell : integer) : boolean;
function IsDoubledPawn(const Board : TBoard; Player, Cell : integer) : boolean;

function PawnsAreSpread(const Board : TBoard; Player : integer) : boolean;

function IsSupportedPawn(const Board : TBoard; Player, Cell : integer) : boolean;
function IsConnectedPawn(const Board : TBoard; Player, Cell : integer) : boolean;
function IsBackwardPawn(const Board : TBoard; Player, Cell : integer) : boolean;

function KingOnKeySquare(const Board : TBoard; Player, Cell : integer) : boolean;

function IsOpenFile(const Board : TBoard; Cell : integer) : boolean;
function IsSemiOpenFile(const Board : TBoard; Player, Cell : integer) : boolean;

function RemainingMoveCountEstimate(const Board : TBoard) : integer;
function RemainingMoveCountEstimate_Alt(const Board : TBoard; MoveNumber : UInt64) : integer;

function Q_Eval(alpha, beta: Integer; var Board : TBoard; PrevMove : TMove): integer;

var
  PawnHashTable : T_PawnHash_Table;
  EvalHashTable : T_EvalHash_Table;

implementation

  uses
    Search;


// ================= Eval Hash ==================================================


// score [-32767..32767]

procedure T_EvalHash_Table.StoreScore(HashCode : UInt64; Score : integer);
  var
    index, Data : UInt64;

  begin
  index := UInt64(HashCode and TableMask);

  Data := UInt64(Score + 65536);

  Table[index].UID := HashCode xor Data;
  Table[index].Data := Data;
  end;


function T_EvalHash_Table.RetrieveScore(HashCode : UInt64; var score : integer) : boolean;
  var
    index, UID, Data : UInt64;

  begin
  result := false;
  index := (HashCode and TableMask);

  UID := Table[index].UID;
  Data := Table[index].Data;

  if (UID xor Data) = HashCode then
    begin
    score := integer(Data) - 65536;
    exit(true);
    end;
  end;


procedure T_EvalHash_Table.ClearTable;
  var
    i : integer;

  begin
  for i := 0 to TableSize - 1 do
    begin
    Table[i].UID := 0;
    Table[i].Data := 0;
    end;
  end;


// ================= PawnHash ==================================================

// score [-32768..32767]

procedure T_PawnHash_Table.StoreData(HashCode : UInt64; score : integer; Passers : UInt64);
  var
    index, Data : UInt64;

  begin
  index := UInt64(HashCode and TableMask);

  Data := (Passers shl 8) or UInt64((score + 32768) and $FFFF);

  Table[index].UID := HashCode xor Data;
  Table[index].Data := Data;
  end;


function T_PawnHash_Table.RetrieveData(HashCode : UInt64; var score : integer; var Passers : UInt64) : boolean;
  var
    index, UID, Data : UInt64;

  begin
  result := false;
  index := (HashCode and TableMask);

  UID := Table[index].UID;
  Data := Table[index].Data;

  if (UID xor Data) = HashCode then
    begin
    score := integer(Data and $FFFF) - 32768;
    Passers := (Data shr 8) and UInt64($00FFFFFFFFFFFF00);
    exit(true);
    end;
  end;


procedure T_PawnHash_Table.ClearTable;
  var
    i : integer;

  begin
  for i := 0 to TableSize - 1 do
    begin
    Table[i].Data := 0;
    end;
  end;


// ====================== misc functions =======================================


function Distance(Cell1, Cell2 : integer) : integer;    inline;
  begin
  result := max( abs(Cell1 shr 3 - Cell2 shr 3), abs(Cell1 and $7 - Cell2 and $7));
  end;


function FileMask(Cell : integer) : UInt64;             inline;
  begin
  result := UInt64($0101010101010101) shl (Cell and $7);
  end;


function RankMask(Cell : integer) : UInt64;             inline;
  begin
  result := UInt64($00000000000000FF) shl ((Cell shr 3) * 8);
  end;


function RanksBelowMask(rank : integer) : UInt64;     inline
  begin
  result := UInt64($00FFFFFFFFFFFFFF) shr (56 - rank * 8);
  end;


function RanksAboveMask(rank : integer) : UInt64;     inline
  begin
  result := UInt64($FFFFFFFFFFFFFF00) shl (rank * 8);
  end;


// ===================== pawn Eval functions ===================================


function IsOpenFile(const Board : TBoard; Cell : integer) : boolean;

  // An open file is one with no pawns on it

  begin
  result := BitCount(FileMask(Cell) and Board.Pawns) = 0
  end;


function IsSemiOpenFile(const Board : TBoard; Player, Cell : integer) : boolean;

  // A semi open file is one containing only opponent pawns

  begin
  if Player = white then
    result := BitCount(FileMask(Cell) and Board.WhitePegs and Board.Pawns) = 0
   else
    result := BitCount(FileMask(Cell) and Board.BlackPegs and Board.Pawns) = 0;
  end;


function IsIsolatedPawn(const Board : TBoard; Player, Cell : integer) : boolean;

  // An isolated pawn is a pawn that has no pawns of the same color on neighbouring files

  begin
  if Player = white then
    result := (IsolatedPawnMask[Cell and $7] and Board.WhitePegs and Board.Pawns = 0)
   else
    result := (IsolatedPawnMask[Cell and $7] and Board.BlackPegs and Board.Pawns = 0);
  end;


function IsDoubledPawn(const Board : TBoard; Player, Cell : integer) : boolean;

  // A Pawn is doubled (or, tripled) if there are more pawns of the same color on a given file

  begin
  if Player = white then
    result := (BitCount(DoubledPawnMask[Cell and $7] and Board.WhitePegs and Board.Pawns) > 1)
   else
    result := (BitCount(DoubledPawnMask[Cell and $7] and Board.BlackPegs and Board.Pawns) > 1);
  end;


function IsSupportedPawn(const Board : TBoard; Player, Cell : integer) : boolean;

  // A pawn is Supported if it is located on strong (attacking) square of sister pawn

  begin
  if Player = white then
    result := (WhiteSupportedPawn[Cell-8] and Board.WhitePegs and Board.Pawns) <> 0
   else
    result := (BlackSupportedPawn[Cell-8] and Board.BlackPegs and Board.Pawns) <> 0;
  end;


function IsConnectedPawn(const Board : TBoard; Player, Cell : integer) : boolean;

  // A pawn is Connected if 'United with' or 'Supported by' another pawn of same colour

  begin

  if Player = white then
    result := (ConnectedWhitePawn[cell-8] and Board.WhitePegs and Board.Pawns) <> 0
   else
    result := (ConnectedBlackPawn[cell-8] and Board.BlackPegs and Board.Pawns) <> 0;
  end;


function IsBlockedPawn(const Board : TBoard; Player, Cell : integer) : boolean;

  // A pawn is Blocked if there is opponent pawn immediately in front and no captures available

  begin
  if Player = white then
    begin
    result :=  (((UInt64($1) shl (Cell-8)) and Board.BlackPegs and Board.Pawns) <> 0) and        // immediate cell in front is occupied by opponent pawn
               ((Board.WhitePawnCaptures[Cell] and Board.Pawns and (Board.BlackPegs or Board.EnPassant)) = 0)   // no pawn captures available
    end
   else
    begin
    result :=  (((UInt64($1) shl (Cell+8)) and Board.WhitePegs and Board.Pawns) <> 0) and         // immediate cell in front is occupied by opponent pawn
               ((Board.BlackPawnCaptures[Cell] and Board.Pawns and (Board.WhitePegs or Board.EnPassant)) = 0);  // no captures available
    end;
  end;


function IsBackwardPawn(const Board : TBoard; Player, Cell : integer) : boolean;

  // A pawn is Backward when it is behind all pawns of the same color on the adjacent files and cannot be safely advanced.

  begin
  if Player = white then
    result := ((BackwardWhitePawn[cell-8] and Board.WhitePegs and Board.Pawns) = 0) and (cell > 15) and ((BlackSupportedPawn[cell-16] and Board.BlackPegs and Board.Pawns) <> 0)
   else
    result := ((BackwardBlackPawn[cell-8] and Board.BlackPegs and Board.Pawns) = 0) and (cell < 48) and ((WhiteSupportedPawn[cell] and Board.WhitePegs and Board.Pawns) <> 0);
  end;



function PawnsAreSpread(const Board : TBoard; Player : integer) : boolean;

  // player has pawns distributed on both sides of board
  // i.e. one or more pawns on files <= 4 and at same time one or more pawns on files >= 5

  const
    LeftMask =  UInt64($0F0F0F0F0F0F0F0F);
    RightMask = UInt64($F0F0F0F0F0F0F0F0);

  begin
  if Player = white then
    begin
    result :=  (LeftMask and (Board.WhitePegs and Board.Pawns) <> 0) and
               (RightMask and (Board.WhitePegs and Board.Pawns) <> 0);
    end
   else
    begin
    result :=  (LeftMask and (Board.BlackPegs and Board.Pawns) <> 0) and
               (RightMask and (Board.BlackPegs and Board.Pawns) <> 0);
    end;
  end;


function IsPassedPawn(const Board : TBoard; Player, Cell : integer) : boolean;

  // A pawn is passed if there are no opposing pawns to prevent it from advancing to the eighth rank;
  //    i.e. there are no opposing pawns in front of it on either the same file or adjacent files and
  //         no own pawn in front i.e. rear doubled pawn doesn't count.

  begin
  if Player = white then
    result := ((WhitePassMask[Cell] and Board.BlackPegs and Board.Pawns) = 0) and ((WhiteSpanMask[Cell] and Board.WhitePegs and Board.Pawns) = 0)
   else
    result := ((BlackPassMask[Cell] and Board.WhitePegs and Board.Pawns) = 0) and ((BlackSpanMask[Cell] and Board.BlackPegs and Board.Pawns) = 0);
  end;


function KingOnKeySquare(const Board : TBoard; Player, Cell : integer) : boolean;

  begin
  if Player = white then
    result := ((WhiteKeySqrMask[Cell] and Board.WhitePegs and Board.Kings) <> 0)
   else
    result := ((BlackKeySqrMask[Cell] and Board.BlackPegs and Board.Kings) <> 0);
  end;


// A pawn is Isolated if it has no friendly pawn on an adjacent file.

// A pawn is Doubled when it has another friendly pawn on same file.

// A pawn is Double Isolated if it is doubled and isolated.

// A pawn is Supported if it is protected by pawn behind and to side. (one or two pawns can protect)

// A pawn is part of a Phalanx if there is friendly pawn on adjacent file and same rank.

// A pawn is Connected if Supported or part of Phalanx.

// A pawn is Opposed if there is opponent pawn on the same file in direction of advancement.

// A pawn is Blocked  if there is opponent pawn immediately in front.

// A pawn is Backward when it is behind all pawns of the same color on the adjacent files and cannot be safely advanced.  [Penalty]

// Pawns Are Spread : player has pawns distributed on both sides of board

// A pawn is Passed if there are no opposing pawns to prevent it from advancing to the eighth rank;
//    i.e. there are no opposing pawns in front of it on either the same file or adjacent files &
//         there are no own pawns directly in front of it i.e. rear doubled pawn doesn't count.

// A pawn is CandidatePasser if:
//    o  there is no stopper except some levers.
//    o  the only stoppers are the leverPush, but outnumbered.
//    o  there is only one front stopper, which can be levered.
//    o  there are no own pawns in front of it.  i.e. rear doubled pawn doesn't count.


function PawnBonus(const Board : TBoard; var Passers : UInt64) : integer;
  var
    PawnCell, PromotionCell, OpponentKingCell, FlipCell : integer;
    score, eg_score, mg_score : integer;
    Pegs, WhitePawns, BlackPawns : UInt64;

  begin
  result := 0;
  mg_score := 0;
  eg_score := 0;
  Passers := 0;

  WhitePawns := Board.WhitePegs and Board.Pawns;
  BlackPawns := Board.BlackPegs and Board.Pawns;


  Pegs := WhitePawns;      // white pawns

  // if PawnsAreSpread
  if (Board_Left_Half and WhitePawns <> 0) and (Board_Right_Half and WhitePawns <> 0) then     // bonus for white if pawns are spread
    begin
    mg_score := mg_score + PawnWidthBonus_mg * bitcount(WhitePawns);
    eg_score := eg_score + PawnWidthBonus_eg * bitcount(WhitePawns);
    end;

  while Pegs <> 0 do
    begin
    PawnCell := PopLowBit_Alt(Pegs);

    // if IsPassedPawn
    if ((WhitePassMask[PawnCell] and BlackPawns) = 0) and ((WhiteSpanMask[PawnCell] and WhitePawns) = 0) then  // is passed pawn
      begin
      setBit(Passers, PawnCell);
      result := result + PassedPawn_Table[PawnCell];
      end;

    // if IsIsolatedPawn
    if (IsolatedPawnMask[PawnCell and $7] and WhitePawns = 0) then
      begin
      mg_score := mg_score + IsolatedPawnPenalty_mg;
      eg_score := eg_score + IsolatedPawnPenalty_eg;
      end;

    // if IsDoubledPawn
    if (BitCount(DoubledPawnMask[PawnCell and $7] and WhitePawns) > 1) then
      begin
      mg_score := mg_score + DoubledPawnPenalty_mg;
      eg_score := eg_score + DoubledPawnPenalty_eg;
      end;

    // if IsConnectedPawn
    if (ConnectedWhitePawn[PawnCell-8] and WhitePawns) <> 0 then
      result := result + ConnectedPawn_Table[PawnCell];

    // if IsBackwardPawn
    if ((BackwardWhitePawn[PawnCell-8] and WhitePawns) = 0) and (PawnCell > 15) and ((BlackSupportedPawn[PawnCell-16] and BlackPawns) <> 0) then
      begin
      mg_score := mg_score + BackwardPawnPenalty_mg;
      eg_score := eg_score + BackwardPawnPenalty_eg;
      end;

    // if IsBlockedPawn
    if (((UInt64($1) shl (PawnCell-8)) and BlackPawns) <> 0) and ((Board.WhitePawnCaptures[PawnCell] and Board.Pawns and (Board.BlackPegs or Board.EnPassant)) = 0) then  // no pawn captures available
      begin
      if (PawnCell shr 3) = 3 then
        begin
        mg_score := mg_score + BlockedOnRank6Penalty_mg;
        eg_score := eg_score + BlockedOnRank6Penalty_eg;
        end
       else if (PawnCell shr 3) = 2 then
        begin
        mg_score := mg_score + BlockedOnRank7Penalty_mg;
        eg_score := eg_score + BlockedOnRank7Penalty_eg;
        end;
      end;
    end;



  Pegs := BlackPawns;    // black pawns

  // if PawnsAreSpread
  if (Board_Left_Half and BlackPawns <> 0) and (Board_Right_Half and BlackPawns <> 0) then     // bonus for black if pawns are spread
    begin
    mg_score := mg_score - PawnWidthBonus_mg * bitcount(BlackPawns);
    eg_score := eg_score - PawnWidthBonus_eg * bitcount(BlackPawns);
    end;

  while Pegs <> 0 do
    begin
    PawnCell := PopLowBit_Alt(Pegs);
    FlipCell := (7 - PawnCell shr 3)*8 + (PawnCell and $7);

    // if IsPassedPawn
    if ((BlackPassMask[PawnCell] and WhitePawns) = 0) and ((BlackSpanMask[PawnCell] and BlackPawns) = 0) then
      begin
      setBit(Passers, PawnCell);
      result := result - PassedPawn_Table[FlipCell];
      end;

    // if IsIsolatedPawn
    if (IsolatedPawnMask[PawnCell and $7] and BlackPawns = 0) then
      begin
      mg_score := mg_score - IsolatedPawnPenalty_mg;
      eg_score := eg_score - IsolatedPawnPenalty_eg;
      end;

    // if IsDoubledPawn
    if (BitCount(DoubledPawnMask[PawnCell and $7] and BlackPawns) > 1) then
      begin
      mg_score := mg_score - DoubledPawnPenalty_mg;
      eg_score := eg_score - DoubledPawnPenalty_eg;
      end;

    // if IsConnectedPawn
    if (ConnectedBlackPawn[PawnCell-8] and BlackPawns) <> 0 then
      result := result - ConnectedPawn_Table[FlipCell];

    // if IsBackwardPawn
    if ((BackwardBlackPawn[PawnCell-8] and BlackPawns) = 0) and (PawnCell < 48) and ((WhiteSupportedPawn[PawnCell] and WhitePawns) <> 0) then
      begin
      mg_score := mg_score - BackwardPawnPenalty_mg;
      eg_score := eg_score - BackwardPawnPenalty_eg;
      end;

    // if IsBlockedPawn
    if (((UInt64($1) shl (PawnCell+8)) and WhitePawns) <> 0) and ((Board.BlackPawnCaptures[PawnCell] and Board.Pawns and (Board.WhitePegs or Board.EnPassant)) = 0) then
      begin
      if (PawnCell shr 3) = 4 then
        begin
        mg_score := mg_score - BlockedOnRank6Penalty_mg;
        eg_score := eg_score - BlockedOnRank6Penalty_eg;
        end
       else if (PawnCell shr 3) = 5 then
        begin
        mg_score := mg_score - BlockedOnRank7Penalty_mg;
        eg_score := eg_score - BlockedOnRank7Penalty_eg;
        end;
      end;
    end;

  score := (mg_score * Board.GameStage + eg_score * (64 - Board.GameStage)) div 64;
  result := result + score;
  end;


function EvalCalc(const Board : TBoard; Passers : UInt64) : integer;

  var
    WhiteMobBoard, BlackMobBoard, SourcePegs, Moves, BlackKingPrecinct, WhiteKingPrecinct : UInt64;
    WhitePinned, BlackPinned : UInt64;
    SourceCell, FlipCell, WhiteKingCell, BlackKingCell, PawnCell, PromotionCell, Rank : integer;
    WhiteKingAttackIndex, BlackKingAttackIndex : integer;
    Mobility : integer;
    BlackPrecinctPawnCount, WhitePrecinctPawnCount, BlackPrecinctIndex, WhitePrecinctIndex, WhiteKingRegion, BlackKingRegion : integer;
    index, PST, PST_mg, PST_eg, MatBal, AttackBonus, piececount, PieceBonus, Tempo, KingAttack, DefenderBonus, PassedPawnBonus : integer;
    dQ, dR, dB, dN, Pdif, Ndif, Bdif, Rdif, Qdif : integer;
    WhiteKingThreat, BlackKingThreat, WhiteKingKnightThreat, BlackKingKnightThreat, WhiteKingRookThreat, BlackKingRookThreat, WhiteKingBishopThreat, BlackKingBishopThreat : UInt64;
    TempMoves, AdvanceMove, AttackedbyWhite, AttackedbyBlack, PawnAdvancePeg : UInt64;

   // Observation : Eval is never required to evaluate a position that is in check - as it is called only on quiet positions

  begin
  PST := 0;
  PST_mg := 0;
  PST_eg := 0;
  MatBal := 0;
  Mobility := 0;
  AttackBonus := 0;
  PieceBonus := 0;
  KingAttack := 0;
  DefenderBonus := 0;
  PassedPawnBonus := 0;

  AttackedbyWhite := 0;
  AttackedbyBlack := 0;

  BlackKingCell := GetLowBit_Alt(Board.Kings and Board.BlackPegs);
  WhiteKingCell := GetLowBit_Alt(Board.Kings and Board.WhitePegs);

  WhiteKingRookThreat := Board.RookAttack_asm(WhiteKingCell);
  BlackKingRookThreat := Board.RookAttack_asm(BlackKingCell);
  WhiteKingBishopThreat := Board.BishopAttack_asm(WhiteKingCell);
  BlackKingBishopThreat := Board.BishopAttack_asm(BlackKingCell);
  WhiteKingThreat := WhiteKingRookThreat or WhiteKingBishopThreat;
  BlackKingThreat := BlackKingRookThreat or BlackKingBishopThreat;
  WhiteKingKnightThreat := Board.KnightAttack(WhiteKingCell);
  BlackKingKnightThreat := Board.KnightAttack(BlackKingCell);

  WhiteKingRegion := KingRegionIndex[WhiteKingCell];
  BlackKingRegion := KingRegionIndex[FlipLookup[BlackKingCell]];

  WhiteKingAttackIndex := 0;
  WhiteMobBoard := Board.MobilityBoard(White);
  WhiteKingPrecinct := Board.KingMask[WhiteKingCell];
  WhitePrecinctIndex := KingPrecinctIndex[WhiteKingCell];
  WhitePrecinctPawnCount := min(4, bitcount(Board.Pawns and Board.WhitePegs and WhiteKingPrecinct));
  WhitePinned := Board.GetPinnedPegs(Board.WhitePegs);

  BlackKingAttackIndex := 0;
  BlackMobBoard := Board.MobilityBoard(Black);
  BlackKingPrecinct := Board.KingMask[BlackKingCell];
  BlackPrecinctIndex := KingPrecinctIndex[BlackKingCell];
  BlackPrecinctPawnCount := min(4, bitcount(Board.Pawns and Board.BlackPegs and BlackKingPrecinct));
  BlackPinned := Board.GetPinnedPegs(Board.BlackPegs);


  SourcePegs := Board.Knights and Board.WhitePegs;
  piececount := BitCount(SourcePegs);
  Ndif := piececount;
  index := min(piececount, 2);
  if piececount > 2 then
    MatBal := MatBal + (piececount - 2) * ThirdknightValue;

  while SourcePegs <> 0 do
    begin
    SourceCell := PopLowBit_Alt(SourcePegs);
    PST_mg := PST_mg + PST_Table_mg[Knight, SourceCell];
    PST_eg := PST_eg + PST_Table_eg[Knight, SourceCell];

    Moves := Board.KnightMask[SourceCell];
    AttackedbyWhite := AttackedbyWhite or Moves;
    AttackBonus := AttackBonus + bitcount(Moves and BlackKingKnightThreat and not Board.WhitePegs) * AttackBonus_Knight_King_Threat;

    TempMoves := Moves and Board.BlackPegs and not Board.Pawns;
    if TempMoves <> 0 then
      if Board.ToPlay = white then
        begin
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Queens) * AttackBonus_STM[Knight, Queen];
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Rooks) * AttackBonus_STM[Knight, Rook];
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Bishops) * AttackBonus_STM[Knight, Bishop];
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Knights) * AttackBonus_STM[Knight, Knight];

        AttackBonus := AttackBonus + MultiAttackBonus_STM[Knight, bitcount(TempMoves)];
        end
       else
        begin
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Queens) * AttackBonus_OTM[Knight, Queen];
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Rooks) * AttackBonus_OTM[Knight, Rook];
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Bishops) * AttackBonus_OTM[Knight, Bishop];
        //AttackBonus := AttackBonus + bitcount(TempMoves and Board.Knights) * AttackBonus_OTM[Knight, Knight];

        AttackBonus := AttackBonus + MultiAttackBonus_OTM[Knight, bitcount(TempMoves)];
        end;

    DefenderBonus := DefenderBonus + bitcount(Moves and Board.WhitePegs) * DefendedByBonus[Knight];

    if bitcount(Moves and (Board.Rooks or Board.Queens) and Board.BlackPegs) > 1 then
      AttackBonus := AttackBonus + AttackBonus_KnightFork;

    PieceBonus := PieceBonus + distance(SourceCell,  WhiteKingCell) * KingKnightDist_Penalty;

    BlackKingAttackIndex := BlackKingAttackIndex + bitcount(Moves and BlackKingPrecinct);

    if (WhitePinned and (UInt64($1) shl sourceCell)) = 0 then
      Mobility := Mobility + Knight_Mobility[BitCount(Moves and WhiteMobBoard)]
     else
      Mobility := Mobility + PinnedKnight_Penalty;
    end;


  SourcePegs := Board.Bishops and Board.WhitePegs;
  piececount := BitCount(SourcePegs);
  Bdif := piececount;
  index := index + min(piececount, 2) * 3;
  if piececount > 2 then
    MatBal := MatBal + (piececount - 2) * ThirdBishopValue;

  while SourcePegs <> 0 do
    begin
    SourceCell := PopLowBit_Alt(SourcePegs);
    PST_mg := PST_mg + PST_Table_mg[Bishop, SourceCell];
    PST_eg := PST_eg + PST_Table_eg[Bishop, SourceCell];

    Moves := Board.BishopAttack_asm(SourceCell);
    AttackedbyWhite := AttackedbyWhite or Moves;
    AttackBonus := AttackBonus + bitcount(Moves and BlackKingBishopThreat and not Board.WhitePegs) * AttackBonus_Bishop_King_Threat;

    TempMoves := Moves and Board.BlackPegs and not Board.Pawns;
    if TempMoves <> 0 then
      if Board.ToPlay = white then
        begin
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Queens) * AttackBonus_STM[Bishop, Queen];
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Rooks) * AttackBonus_STM[Bishop, Rook];
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Bishops) * AttackBonus_STM[Bishop, Bishop];
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Knights) * AttackBonus_STM[Bishop, Knight];

        AttackBonus := AttackBonus + MultiAttackBonus_STM[Bishop, bitcount(TempMoves)];
        end
       else
        begin
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Queens) * AttackBonus_OTM[Bishop, Queen];
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Rooks) * AttackBonus_OTM[Bishop, Rook];
        //AttackBonus := AttackBonus + bitcount(TempMoves and Board.Bishops) * AttackBonus_OTM[Bishop, Bishop];
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Knights) * AttackBonus_OTM[Bishop, Knight];

        AttackBonus := AttackBonus + MultiAttackBonus_OTM[Bishop, bitcount(TempMoves)];
        end;

    DefenderBonus := DefenderBonus + bitcount(Moves and Board.WhitePegs) * DefendedByBonus[Bishop];

    if bitcount(Moves and (Board.Rooks or Board.Queens) and Board.BlackPegs) > 1 then
      AttackBonus := AttackBonus + AttackBonus_BishopFork;

    PieceBonus := PieceBonus + distance(SourceCell,  WhiteKingCell) * KingBishopDist_Penalty;

    BlackKingAttackIndex := BlackKingAttackIndex + bitcount(Moves and BlackKingPrecinct);

    if ((UInt64($1) shl sourceCell) and whitesqr) <> 0 then
      PieceBonus := PieceBonus + bitcount(Board.Pawns and Board.WhitePegs and whitesqr) * BishopPawn_Penalty
     else
      PieceBonus := PieceBonus + bitcount(Board.Pawns and Board.WhitePegs and blacksqr) * BishopPawn_Penalty;

    PieceBonus := PieceBonus + bitcount(Moves and WhiteMobBoard and Board_Centre_4) * BishopCentreControl_Bonus;

    if (WhitePinned and (UInt64($1) shl sourceCell)) = 0 then
      Mobility := Mobility + Bishop_Mobility[BitCount(Moves and WhiteMobBoard)]
     else
      Mobility := Mobility + PinnedBishop_Penalty;       // pinned so reduced mobility
    end;


  SourcePegs := Board.Rooks and Board.WhitePegs;
  piececount := BitCount(SourcePegs);
  Rdif := piececount;
  index := index + min(piececount, 2) * 9;
  if piececount > 2 then
    MatBal := MatBal + (piececount - 2) * ThirdRookValue;

  while SourcePegs <> 0 do
    begin
    SourceCell := PopLowBit_Alt(SourcePegs);
    PST_mg := PST_mg + PST_Table_mg[Rook, SourceCell];
    PST_eg := PST_eg + PST_Table_eg[Rook, SourceCell];

    Moves := Board.RookAttack_asm(SourceCell);
    AttackedbyWhite := AttackedbyWhite or Moves;
    AttackBonus := AttackBonus + bitcount(Moves and BlackKingRookThreat and not Board.WhitePegs) * AttackBonus_Rook_King_Threat;

    TempMoves := Moves and Board.BlackPegs and not Board.Pawns;
    if TempMoves <> 0 then
      if Board.ToPlay = white then
        begin
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Queens) * AttackBonus_STM[Rook, Queen];
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Rooks) * AttackBonus_STM[Rook, Rook];
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Bishops) * AttackBonus_STM[Rook, Bishop];
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Knights) * AttackBonus_STM[Rook, Knight];

        AttackBonus := AttackBonus + MultiAttackBonus_STM[Rook, bitcount(TempMoves)];
        end
       else
        begin
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Queens) * AttackBonus_OTM[Rook, Queen];
        //AttackBonus := AttackBonus + bitcount(TempMoves and Board.Rooks) * AttackBonus_OTM[Rook, Rook];
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Bishops) * AttackBonus_OTM[Rook, Bishop];
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Knights) * AttackBonus_OTM[Rook, Knight];

        AttackBonus := AttackBonus + MultiAttackBonus_OTM[Rook, bitcount(TempMoves)];
        end;

    PST_mg := PST_mg + bitcount(Moves and Board.WhitePegs) * DefendedByBonus[Rook];

    BlackKingAttackIndex := BlackKingAttackIndex + bitcount(Moves and BlackKingPrecinct);

    if (WhitePinned and (UInt64($1) shl sourceCell)) = 0 then
      Mobility := Mobility + Rook_Mobility[BitCount(Moves and WhiteMobBoard)]
     else
      Mobility := Mobility + PinnedRook_Penalty;

    //if IsOpenFile(Board, SourceCell) then
    if BitCount(FileMask(SourceCell) and Board.Pawns) = 0 then
      begin
      PST_mg := PST_mg + RookOnOpenFile_Bonus_mg;
      PST_eg := PST_eg + RookOnOpenFile_Bonus_eg;
      end
     //else if IsSemiOpenFile(Board, White, SourceCell) then
     else if BitCount(FileMask(SourceCell) and Board.WhitePegs and Board.Pawns) = 0 then
      begin
      PST_mg := PST_mg + RookOnSemiOpenFile_Bonus_mg;
      PST_eg := PST_eg + RookOnSemiOpenFile_Bonus_eg;
      end;
    end;


  SourcePegs := Board.Queens and Board.WhitePegs;
  piececount := BitCount(SourcePegs);
  Qdif := piececount;
  index := index + min(piececount, 1) * 27;
  if piececount > 1 then
    MatBal := MatBal + (piececount - 1) * SecondQueenValue;

  while SourcePegs <> 0 do
    begin
    SourceCell := PopLowBit_Alt(SourcePegs);

    PST_mg := PST_mg + PST_Table_mg[Queen, SourceCell];
    PST_eg := PST_eg + PST_Table_eg[Queen, SourceCell];

    Moves := Board.QueenAttack(SourceCell);
    AttackedbyWhite := AttackedbyWhite or Moves;

    if Board.ToPlay = white then
      AttackBonus := AttackBonus + bitcount(Moves and BlackKingThreat) * AttackBonus_Queen_King_Threat_STM
     else
      AttackBonus := AttackBonus + bitcount(Moves and BlackKingThreat) * AttackBonus_Queen_King_Threat_OTM;

    TempMoves := Moves and Board.BlackPegs and not Board.Pawns;
    if TempMoves <> 0 then
      if Board.ToPlay = white then
        begin
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Queens) * AttackBonus_STM[Queen, Queen];
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Rooks) * AttackBonus_STM[Queen, Rook];
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Bishops) * AttackBonus_STM[Queen, Bishop];
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Knights) * AttackBonus_STM[Queen, Knight];

        AttackBonus := AttackBonus + MultiAttackBonus_STM[Queen, bitcount(TempMoves)];
        end
       else
        begin
        //AttackBonus := AttackBonus + bitcount(TempMoves and Board.Queens) * AttackBonus_OTM[Queen, Queen];
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Rooks) * AttackBonus_OTM[Queen, Rook];
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Bishops) * AttackBonus_OTM[Queen, Bishop];
        AttackBonus := AttackBonus + bitcount(TempMoves and Board.Knights) * AttackBonus_OTM[Queen, Knight];

        AttackBonus := AttackBonus + MultiAttackBonus_OTM[Queen, bitcount(TempMoves)];
        end;

    PST_mg := PST_mg + bitcount(Moves and Board.WhitePegs) * DefendedByBonus[Queen];

    BlackKingAttackIndex := BlackKingAttackIndex + bitcount(Moves and BlackKingPrecinct);

    if (WhitePinned and (UInt64($1) shl sourceCell)) = 0 then
      Mobility := Mobility + Queen_Mobility[BitCount(Moves and WhiteMobBoard)]
     else
      begin
      if Board.ToPlay = white then
        Mobility := Mobility + PinnedQueen_Penalty_STM
       else
        Mobility := Mobility + PinnedQueen_Penalty_OTM;
      end;
    end;


  SourcePegs := Board.WhitePegs and Board.Pawns;
  piececount := BitCount(SourcePegs);
  Pdif := piececount;
  MatBal := MatBal + Material_Table[index, piececount];

  Moves := ((SourcePegs and not Board_RightEdge) shr 7);
  AttackedbyWhite := AttackedbyWhite or Moves;
  TempMoves := Moves and Board.BlackPegs and not Board.Pawns;
  if TempMoves <> 0 then
    if Board.ToPlay = white then
      begin
      AttackBonus := AttackBonus + bitcount(TempMoves and Board.Queens) * AttackBonus_STM[Pawn, Queen];
      AttackBonus := AttackBonus + bitcount(TempMoves and Board.Rooks) * AttackBonus_STM[Pawn, Rook];
      AttackBonus := AttackBonus + bitcount(TempMoves and Board.Bishops) * AttackBonus_STM[Pawn, Bishop];
      AttackBonus := AttackBonus + bitcount(TempMoves and Board.Knights) * AttackBonus_STM[Pawn, Knight];
      end
     else
      begin
      AttackBonus := AttackBonus + bitcount(TempMoves and Board.Queens) * AttackBonus_OTM[Pawn, Queen];
      AttackBonus := AttackBonus + bitcount(TempMoves and Board.Rooks) * AttackBonus_OTM[Pawn, Rook];
      AttackBonus := AttackBonus + bitcount(TempMoves and Board.Bishops) * AttackBonus_OTM[Pawn, Bishop];
      AttackBonus := AttackBonus + bitcount(TempMoves and Board.Knights) * AttackBonus_OTM[Pawn, Knight];
      end;

  DefenderBonus := DefenderBonus + bitcount(Moves and Board.WhitePegs) * DefendedByBonus[Pawn];

  BlackKingAttackIndex := BlackKingAttackIndex + bitcount(Moves and BlackKingPrecinct);

  Moves := ((SourcePegs and not Board_LeftEdge) shr 9);
  AttackedbyWhite := AttackedbyWhite or Moves;
  TempMoves := Moves and Board.BlackPegs and not Board.Pawns;
  if TempMoves <> 0 then
    if Board.ToPlay = white then
      begin
      AttackBonus := AttackBonus + bitcount(TempMoves and Board.Queens) * AttackBonus_STM[Pawn, Queen];
      AttackBonus := AttackBonus + bitcount(TempMoves and Board.Rooks) * AttackBonus_STM[Pawn, Rook];
      AttackBonus := AttackBonus + bitcount(TempMoves and Board.Bishops) * AttackBonus_STM[Pawn, Bishop];
      AttackBonus := AttackBonus + bitcount(TempMoves and Board.Knights) * AttackBonus_STM[Pawn, Knight];
      end
     else
      begin
      AttackBonus := AttackBonus + bitcount(TempMoves and Board.Queens) * AttackBonus_OTM[Pawn, Queen];
      AttackBonus := AttackBonus + bitcount(TempMoves and Board.Rooks) * AttackBonus_OTM[Pawn, Rook];
      AttackBonus := AttackBonus + bitcount(TempMoves and Board.Bishops) * AttackBonus_OTM[Pawn, Bishop];
      AttackBonus := AttackBonus + bitcount(TempMoves and Board.Knights) * AttackBonus_OTM[Pawn, Knight];
      end;

  DefenderBonus := DefenderBonus + bitcount(Moves and Board.WhitePegs) * DefendedByBonus[Pawn];

  BlackKingAttackIndex := BlackKingAttackIndex + bitcount(Moves and BlackKingPrecinct);

  while SourcePegs <> 0 do
    begin
    SourceCell := PopLowBit_Alt(SourcePegs);
    PST_mg := PST_mg + PST_Table_Pawn_mg[WhiteKingRegion, SourceCell];
    PST_eg := PST_eg + PST_Table_Pawn_eg[WhiteKingRegion, SourceCell];
    end;

  SourcePegs := Board.WhitePegs and Board.Kings;
  SourceCell := PopLowBit_Alt(SourcePegs);

  PST_mg := PST_mg + PST_Table_mg[King, SourceCell];
  PST_eg := PST_eg + PST_Table_eg[King, SourceCell];

  //if IsOpenFile(Board, SourceCell) then
  if BitCount(FileMask(SourceCell) and Board.Pawns) = 0 then
    begin
    PST_mg := PST_mg + KingOnOpenFile_Penalty_mg;
    PST_eg := PST_eg + KingOnOpenFile_Penalty_eg;
    end;

  //if IsSemiOpenFile(Board, White, SourceCell) then
  if BitCount(FileMask(SourceCell) and Board.WhitePegs and Board.Pawns) = 0 then
    begin
    PST_mg := PST_mg + KingOnSemiOpenFile_Penalty_mg;
    PST_eg := PST_eg + KingOnSemiOpenFile_Penalty_eg;
    end;

  Moves := Board.KingMask[SourceCell] and Board.BlackPegs and Board.Pawns;
  AttackBonus := AttackBonus + bitcount(Moves) * AttackBonus_King_Pawn;

  Moves := WhiteKingThreat and not Board.WhitePegs;
  PST_mg := PST_mg + KingExposure_Penalty_mg[WhitePrecinctIndex, bitcount(moves)];
  PST_eg := PST_eg + KingExposure_Penalty_eg[WhitePrecinctIndex, bitcount(moves)];

  if (SourceCell and $7) > 0 then
    begin
    Moves := Board.QueenAttack(SourceCell - 1) and not Board.WhitePegs;
    PST_mg := PST_mg + KingAdjExposure_Penalty_mg[WhitePrecinctIndex, bitcount(moves)];
    PST_eg := PST_eg + KingAdjExposure_Penalty_eg[WhitePrecinctIndex, bitcount(moves)];
    end;

  if (SourceCell and $7) < 7 then
    begin
    Moves := Board.QueenAttack(SourceCell + 1) and not Board.WhitePegs;
    PST_mg := PST_mg + KingAdjExposure_Penalty_mg[WhitePrecinctIndex, bitcount(moves)];
    PST_eg := PST_eg + KingAdjExposure_Penalty_eg[WhitePrecinctIndex, bitcount(moves)];
    end;

  AttackedbyWhite := AttackedbyWhite and not Board.WhitePegs;

  //===========================================================================


  SourcePegs := Board.Knights and Board.BlackPegs;
  piececount := BitCount(SourcePegs);
  Ndif := Ndif - piececount;
  index := min(piececount, 2);
  if piececount > 2 then
    MatBal := MatBal - (piececount - 2) * ThirdKnightValue;

  while SourcePegs <> 0 do
    begin
    SourceCell := PopLowBit_Alt(SourcePegs);
    FlipCell := FlipLookup[SourceCell];

    PST_mg := PST_mg - PST_Table_mg[Knight, FlipCell];
    PST_eg := PST_eg - PST_Table_eg[Knight, FlipCell];

    Moves := Board.KnightMask[SourceCell];
    AttackedbyBlack := AttackedbyBlack or Moves;
    AttackBonus := AttackBonus - bitcount(Moves and WhiteKingKnightThreat and not Board.BlackPegs) * AttackBonus_Knight_King_Threat;

    TempMoves := Moves and Board.WhitePegs and not Board.Pawns;
    if TempMoves <> 0 then
      if Board.ToPlay = black then
        begin
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Queens) * AttackBonus_STM[Knight, Queen];
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Rooks) * AttackBonus_STM[Knight, Rook];
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Bishops) * AttackBonus_STM[Knight, Bishop];
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Knights) * AttackBonus_STM[Knight, Knight];

        AttackBonus := AttackBonus - MultiAttackBonus_STM[Knight, bitcount(TempMoves)];
        end
       else
        begin
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Queens) * AttackBonus_OTM[Knight, Queen];
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Rooks) * AttackBonus_OTM[Knight, Rook];
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Bishops) * AttackBonus_OTM[Knight, Bishop];
        //AttackBonus := AttackBonus - bitcount(TempMoves and Board.Knights) * AttackBonus_OTM[Knight, Knight];

        AttackBonus := AttackBonus - MultiAttackBonus_OTM[Knight, bitcount(TempMoves)];
        end;

    DefenderBonus := DefenderBonus - bitcount(Moves and Board.BlackPegs) * DefendedByBonus[Knight];

    if bitcount(Moves and (Board.Rooks or Board.Queens) and Board.WhitePegs) > 1 then
      AttackBonus := AttackBonus - AttackBonus_KnightFork;

    PieceBonus := PieceBonus - distance(SourceCell,  BlackKingCell) * KingKnightDist_Penalty;

    WhiteKingAttackIndex := WhiteKingAttackIndex + bitcount(Moves and WhiteKingPrecinct);

    if (BlackPinned and (UInt64($1) shl sourceCell)) = 0 then
      Mobility := Mobility - Knight_Mobility[BitCount(Moves and BlackMobBoard)]
     else
      Mobility := Mobility - PinnedKnight_Penalty;
    end;


  SourcePegs := Board.Bishops and Board.BlackPegs;
  piececount := BitCount(SourcePegs);
  Bdif := Bdif - piececount;
  index := index + min(piececount, 2) * 3;
  if piececount > 2 then
    MatBal := MatBal - (piececount - 2) * ThirdBishopValue;

  while SourcePegs <> 0 do
    begin
    SourceCell := PopLowBit_Alt(SourcePegs);
    FlipCell := FlipLookup[SourceCell];

    PST_mg := PST_mg - PST_Table_mg[Bishop, FlipCell];
    PST_eg := PST_eg - PST_Table_eg[Bishop, FlipCell];

    Moves := Board.BishopAttack_asm(SourceCell);
    AttackedbyBlack := AttackedbyBlack or Moves;
    AttackBonus := AttackBonus - bitcount(Moves and WhiteKingBishopThreat and not Board.BlackPegs) * AttackBonus_Bishop_King_Threat;

    TempMoves := Moves and Board.WhitePegs and not Board.Pawns;
    if TempMoves <> 0 then
      if Board.ToPlay = black then
        begin
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Queens) * AttackBonus_STM[Bishop, Queen];
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Rooks) * AttackBonus_STM[Bishop, Rook];
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Bishops) * AttackBonus_STM[Bishop, Bishop];
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Knights) * AttackBonus_STM[Bishop, Knight];

        AttackBonus := AttackBonus - MultiAttackBonus_STM[Bishop, bitcount(TempMoves)];
        end
       else
        begin
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Queens) * AttackBonus_OTM[Bishop, Queen];
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Rooks) * AttackBonus_OTM[Bishop,  Rook];
        //AttackBonus := AttackBonus - bitcount(TempMoves and Board.Bishops) * AttackBonus_OTM[Bishop, Bishop];
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Knights) * AttackBonus_OTM[Bishop, Knight];

        AttackBonus := AttackBonus - MultiAttackBonus_OTM[Bishop, bitcount(TempMoves)];
        end;

    DefenderBonus := DefenderBonus - bitcount(Moves and Board.BlackPegs) * DefendedByBonus[Bishop];

    if bitcount(Moves and (Board.Rooks or Board.Queens) and Board.WhitePegs) > 1 then
      AttackBonus := AttackBonus - AttackBonus_BishopFork;

    PieceBonus := PieceBonus - distance(SourceCell,  BlackKingCell) * KingBishopDist_Penalty;

    WhiteKingAttackIndex := WhiteKingAttackIndex + bitcount(Moves and WhiteKingPrecinct);

    if ((UInt64($1) shl sourceCell) and whitesqr) <> 0 then
      PieceBonus := PieceBonus - bitcount(Board.Pawns and Board.BlackPegs and whitesqr) * BishopPawn_Penalty
     else
      PieceBonus := PieceBonus - bitcount(Board.Pawns and Board.BlackPegs and blacksqr) * BishopPawn_Penalty;

    PieceBonus := PieceBonus - bitcount(Moves and BlackMobBoard and Board_Centre_4) * BishopCentreControl_Bonus;

    if (BlackPinned and (UInt64($1) shl sourceCell)) = 0 then
      Mobility := Mobility - Bishop_Mobility[BitCount(Moves and BlackMobBoard)]
     else
      Mobility := Mobility - PinnedBishop_Penalty;
    end;


  SourcePegs := Board.Rooks and Board.BlackPegs;
  piececount := BitCount(SourcePegs);
  Rdif := Rdif - piececount;
  index := index + min(piececount, 2) * 9;
  if piececount > 2 then
    MatBal := MatBal - (piececount - 2) * ThirdRookValue;

  while SourcePegs <> 0 do
    begin
    SourceCell := PopLowBit_Alt(SourcePegs);
    FlipCell := FlipLookup[SourceCell];

    PST_mg := PST_mg - PST_Table_mg[Rook, FlipCell];
    PST_eg := PST_eg - PST_Table_eg[Rook, FlipCell];

    Moves := Board.RookAttack_asm(SourceCell);
    AttackedbyBlack := AttackedbyBlack or Moves;
    AttackBonus := AttackBonus - bitcount(Moves and WhiteKingRookThreat and not Board.BlackPegs) * AttackBonus_Rook_King_Threat;

    TempMoves := Moves and Board.WhitePegs and not Board.Pawns;
    if TempMoves <> 0 then
      if Board.ToPlay = black then
        begin
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Queens) * AttackBonus_STM[Rook, Queen];
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Rooks) * AttackBonus_STM[Rook, Rook];
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Bishops) * AttackBonus_STM[Rook, Bishop];
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Knights) * AttackBonus_STM[Rook, Knight];

        AttackBonus := AttackBonus - MultiAttackBonus_STM[Rook, bitcount(TempMoves)];
        end
       else
        begin
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Queens) * AttackBonus_OTM[Rook, Queen];
        //AttackBonus := AttackBonus - bitcount(TempMoves and Board.Rooks) * AttackBonus_OTM[Rook, Rook];
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Bishops) * AttackBonus_OTM[Rook, Bishop];
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Knights) * AttackBonus_OTM[Rook, Knight];

        AttackBonus := AttackBonus - MultiAttackBonus_OTM[Rook, bitcount(TempMoves)];
        end;

    PST_mg := PST_mg - bitcount(Moves and Board.BlackPegs) * DefendedByBonus[Rook];

    WhiteKingAttackIndex := WhiteKingAttackIndex + bitcount(Moves and WhiteKingPrecinct);

    if (BlackPinned and (UInt64($1) shl sourceCell)) = 0 then
      Mobility := Mobility - Rook_Mobility[BitCount(Moves and BlackMobBoard)]
     else
      Mobility := Mobility - PinnedRook_Penalty;

    //if IsOpenFile(Board, SourceCell) then
    if BitCount(FileMask(SourceCell) and Board.Pawns) = 0 then
      begin
      PST_mg := PST_mg - RookOnOpenFile_Bonus_mg;
      PST_eg := PST_eg - RookOnOpenFile_Bonus_eg;
      end
    // else if IsSemiOpenFile(Board, Black, SourceCell) then
     else if BitCount(FileMask(SourceCell) and Board.BlackPegs and Board.Pawns) = 0 then
      begin
      PST_mg := PST_mg - RookOnSemiOpenFile_Bonus_mg;
      PST_eg := PST_eg - RookOnSemiOpenFile_Bonus_eg;
      end;
    end;


  SourcePegs := Board.Queens and Board.BlackPegs;
  piececount := BitCount(SourcePegs);
  Qdif := Qdif - piececount;
  index := index + min(piececount, 1) * 27;
  if piececount > 1 then
    MatBal := MatBal - (piececount - 1) * SecondQueenValue;

  while SourcePegs <> 0 do
    begin
    SourceCell := PopLowBit_Alt(SourcePegs);
    FlipCell := FlipLookup[SourceCell];

    PST_mg := PST_mg - PST_Table_mg[Queen, FlipCell];
    PST_eg := PST_eg - PST_Table_eg[Queen, FlipCell];

    Moves := Board.QueenAttack(SourceCell);
    AttackedbyBlack := AttackedbyBlack or Moves;

    if Board.ToPlay = black then
      AttackBonus := AttackBonus - bitcount(Moves and WhiteKingThreat) * AttackBonus_Queen_King_Threat_STM
     else
      AttackBonus := AttackBonus - bitcount(Moves and WhiteKingThreat) * AttackBonus_Queen_King_Threat_OTM;

    TempMoves := Moves and Board.WhitePegs and not Board.Pawns;
    if TempMoves <> 0 then
      if Board.ToPlay = black then
        begin
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Queens) * AttackBonus_STM[Queen, Queen];
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Rooks) * AttackBonus_STM[Queen, Rook];
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Bishops) * AttackBonus_STM[Queen, Bishop];
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Knights) * AttackBonus_STM[Queen, Knight];

        AttackBonus := AttackBonus - MultiAttackBonus_STM[Queen, bitcount(TempMoves)];
        end
       else
        begin
        //AttackBonus := AttackBonus - bitcount(TempMoves and Board.Queens) * AttackBonus_OTM[Queen, Queen];
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Rooks) * AttackBonus_OTM[Queen, Rook];
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Bishops) * AttackBonus_OTM[Queen, Bishop];
        AttackBonus := AttackBonus - bitcount(TempMoves and Board.Knights) * AttackBonus_OTM[Queen, Knight];

        AttackBonus := AttackBonus - MultiAttackBonus_OTM[Queen, bitcount(TempMoves)];
        end;

    PST_mg := PST_mg - bitcount(Moves and Board.BlackPegs) * DefendedByBonus[Queen];

    WhiteKingAttackIndex := WhiteKingAttackIndex + bitcount(Moves and WhiteKingPrecinct);

    if (BlackPinned and (UInt64($1) shl sourceCell)) = 0 then
      Mobility := Mobility - Queen_Mobility[BitCount(Moves and BlackMobBoard)]
     else
      begin
      if Board.ToPlay = black then
        Mobility := Mobility - PinnedQueen_Penalty_STM
       else
        Mobility := Mobility - PinnedQueen_Penalty_OTM;
      end;
    end;


  SourcePegs := Board.BlackPegs and Board.Pawns;
  piececount := BitCount(SourcePegs);
  Pdif := Pdif - piececount;
  MatBal := MatBal - Material_Table[index, piececount];

  Moves := ((SourcePegs and not Board_RightEdge) shl 9);
  AttackedbyBlack := AttackedbyBlack or Moves;
  TempMoves := Moves and Board.WhitePegs and not Board.Pawns;
  if TempMoves <> 0 then
    if Board.ToPlay = black then
      begin
      AttackBonus := AttackBonus - bitcount(TempMoves and Board.Queens) * AttackBonus_STM[Pawn, Queen];
      AttackBonus := AttackBonus - bitcount(TempMoves and Board.Rooks) * AttackBonus_STM[Pawn, Rook];
      AttackBonus := AttackBonus - bitcount(TempMoves and Board.Bishops) * AttackBonus_STM[Pawn, Bishop];
      AttackBonus := AttackBonus - bitcount(TempMoves and Board.Knights) * AttackBonus_STM[Pawn, Knight];
      end
     else
      begin
      AttackBonus := AttackBonus - bitcount(TempMoves and Board.Queens) * AttackBonus_OTM[Pawn, Queen];
      AttackBonus := AttackBonus - bitcount(TempMoves and Board.Rooks) * AttackBonus_OTM[Pawn, Rook];
      AttackBonus := AttackBonus - bitcount(TempMoves and Board.Bishops) * AttackBonus_OTM[Pawn, Bishop];
      AttackBonus := AttackBonus - bitcount(TempMoves and Board.Knights) * AttackBonus_OTM[Pawn, Knight];
      end;

  DefenderBonus := DefenderBonus - bitcount(Moves and Board.BlackPegs) * DefendedByBonus[Pawn];
  WhiteKingAttackIndex := WhiteKingAttackIndex + bitcount(Moves and WhiteKingPrecinct);

  Moves := ((SourcePegs and not Board_LeftEdge) shl 7);
  AttackedbyBlack := AttackedbyBlack or Moves;
  TempMoves := Moves and Board.WhitePegs and not Board.Pawns;
  if TempMoves <> 0 then
    if Board.ToPlay = black then
      begin
      AttackBonus := AttackBonus - bitcount(TempMoves and Board.Queens) * AttackBonus_STM[Pawn, Queen];
      AttackBonus := AttackBonus - bitcount(TempMoves and Board.Rooks) * AttackBonus_STM[Pawn, Rook];
      AttackBonus := AttackBonus - bitcount(TempMoves and Board.Bishops) * AttackBonus_STM[Pawn, Bishop];
      AttackBonus := AttackBonus - bitcount(TempMoves and Board.Knights) * AttackBonus_STM[Pawn, Knight];
      end
     else
      begin
      AttackBonus := AttackBonus - bitcount(TempMoves and Board.Queens) * AttackBonus_OTM[Pawn, Queen];
      AttackBonus := AttackBonus - bitcount(TempMoves and Board.Rooks) * AttackBonus_OTM[Pawn, Rook];
      AttackBonus := AttackBonus - bitcount(TempMoves and Board.Bishops) * AttackBonus_OTM[Pawn, Bishop];
      AttackBonus := AttackBonus - bitcount(TempMoves and Board.Knights) * AttackBonus_OTM[Pawn, Knight];
      end;

  DefenderBonus := DefenderBonus - bitcount(Moves and Board.BlackPegs) * DefendedByBonus[Pawn];
  WhiteKingAttackIndex := WhiteKingAttackIndex + bitcount(Moves and WhiteKingPrecinct);

  while SourcePegs <> 0 do
    begin
    SourceCell := PopLowBit_Alt(SourcePegs);
    FlipCell := FlipLookup[SourceCell];

    PST_mg := PST_mg - PST_Table_Pawn_mg[BlackKingRegion, FlipCell];
    PST_eg := PST_eg - PST_Table_Pawn_eg[BlackKingRegion, FlipCell];
    end;


  SourcePegs := Board.BlackPegs and Board.Kings;
  SourceCell := PopLowBit_Alt(SourcePegs);
  FlipCell := FlipLookup[SourceCell];

  PST_mg := PST_mg - PST_Table_mg[King, FlipCell];
  PST_eg := PST_eg - PST_Table_eg[King, FlipCell];

  //if IsOpenFile(Board, SourceCell) then
  if BitCount(FileMask(SourceCell) and Board.Pawns) = 0 then
    begin
    PST_mg := PST_mg - KingOnOpenFile_Penalty_mg;
    PST_eg := PST_eg - KingOnOpenFile_Penalty_eg;
    end;

  //if IsSemiOpenFile(Board, Black, SourceCell) then
  if BitCount(FileMask(SourceCell) and Board.BlackPegs and Board.Pawns) = 0 then
    begin
    PST_mg := PST_mg - KingOnSemiOpenFile_Penalty_mg;
    PST_eg := PST_eg - KingOnSemiOpenFile_Penalty_eg;
    end;

  Moves := Board.KingMask[SourceCell] and Board.WhitePegs and Board.Pawns;
  AttackBonus := AttackBonus - bitcount(Moves) * AttackBonus_King_Pawn;

  Moves := BlackKingThreat and not Board.BlackPegs;
  PST_mg := PST_mg - KingExposure_Penalty_mg[BlackPrecinctIndex, bitcount(moves)];
  PST_eg := PST_eg - KingExposure_Penalty_eg[BlackPrecinctIndex, bitcount(moves)];

  if (SourceCell and $7) > 0 then
    begin
    Moves := Board.QueenAttack(SourceCell - 1) and not Board.BlackPegs;
    PST_mg := PST_mg - KingAdjExposure_Penalty_mg[BlackPrecinctIndex, bitcount(moves)];
    PST_eg := PST_eg - KingAdjExposure_Penalty_eg[BlackPrecinctIndex, bitcount(moves)];
    end;

  if (SourceCell and $7) < 7 then
    begin
    Moves := Board.QueenAttack(SourceCell + 1) and not Board.BlackPegs;
    PST_mg := PST_mg - KingAdjExposure_Penalty_mg[BlackPrecinctIndex, bitcount(moves)];
    PST_eg := PST_eg - KingAdjExposure_Penalty_eg[BlackPrecinctIndex, bitcount(moves)];
    end;

  AttackedbyBlack := AttackedbyBlack and not Board.BlackPegs;

  // passed pawns  =============================================================

  SourcePegs := Board.WhitePegs and Board.Pawns and Passers;
  while SourcePegs <> 0 do
    begin
    SourceCell := PopLowBit_Alt(SourcePegs);

    if Board.PawnsOnly(Black) then
      begin
      // if path not blocked by own piece
      if (WhiteSpanMask[SourceCell] and Board.WhitePegs) = 0 then
        begin
        // check if opponent king outside 'pawn square' & give bonus if so
        Rank :=  SourceCell shr 3;
        PromotionCell := SourceCell and $7;
        if min(5, Distance(SourceCell, PromotionCell)) < Distance(BlackKingCell, PromotionCell) - Board.ToPlay then
          PassedPawnBonus := PassedPawnBonus + UnstoppableBonus_eg[Rank];
        end;

      // if KingOnKeySquare
      if Board.KingOnly(Black) then
        if (Board.ToPlay = white) or (Distance(BlackKingCell, SourceCell) > 1) then
          if  ((WhiteKeySqrMask[SourceCell] and Board.WhitePegs and Board.Kings) <> 0) then
            PassedPawnBonus := PassedPawnBonus + KingEscortBonus_eg;

      // king proximity
      PassedPawnBonus := PassedPawnBonus + KingProximityBonusA_eg[Distance(SourceCell, WhiteKingCell) - Distance(SourceCell, BlackKingCell) - (1 - 2*Board.ToPlay)];
      end                                                                                                                                // -1 for white to move, +1 if black to move                                                                                                                                         // -1 for white to m
     else
      begin
      if (UInt64($1) shl (SourceCell - 8) and (Board.WhitePegs or Board.BlackPegs)) = 0 then   // square in front is unoccupied, can advance
        begin
        PawnAdvancePeg := UInt64($1) shl (SourceCell - 8);
        if ((AttackedbyBlack and PawnAdvancePeg) <> 0) then                     // next square attacked by black
          begin
          if ((AttackedbyWhite and PawnAdvancePeg) = 0) then                    // next square not defended by white
            PassedPawnBonus := PassedPawnBonus + PasserBlockedPenaltyB_eg       // passer can be captured on next square
          end
         else
          PassedPawnBonus := PassedPawnBonus + PasserCanAdvanceBonusA_eg;       // passer can safely advance one square forward
        end
       else
        PassedPawnBonus := PassedPawnBonus + PasserBlockedPenaltyA_eg;          // next square in front is blocked

      // king proximity
      PassedPawnBonus := PassedPawnBonus + KingProximityBonusB_eg[Distance(SourceCell, WhiteKingCell) - Distance(SourceCell, BlackKingCell)];                                                                                                      // -1 for white to m
      end;
    end;


  SourcePegs := Board.BlackPegs and Board.Pawns and Passers;
  while SourcePegs <> 0 do
    begin
    SourceCell := PopLowBit_Alt(SourcePegs);
    if Board.PawnsOnly(White) then
      begin
      // if path not blocked by own piece
      if (BlackSpanMask[SourceCell] and Board.BlackPegs) = 0 then
        begin
        // check if opponent king outside 'pawn square' & give bonus if so
        Rank :=  SourceCell shr 3;
        PromotionCell := (SourceCell and $7) + 56;
        if min(5, Distance(SourceCell, PromotionCell)) < Distance(WhiteKingCell, PromotionCell) - (1 - Board.ToPlay) then
          PassedPawnBonus := PassedPawnBonus - UnstoppableBonus_eg[7-Rank];
        end;

      // if KingOnKeySquare
      if Board.KingOnly(White) then
        if (Board.ToPlay = black) or (Distance(WhiteKingCell, SourceCell) > 1) then
          if  ((BlackKeySqrMask[SourceCell] and Board.BlackPegs and Board.Kings) <> 0) then
            PassedPawnBonus := PassedPawnBonus - KingEscortBonus_eg;

      // king proximity bonus
      PassedPawnBonus := PassedPawnBonus - KingProximityBonusA_eg[Distance(SourceCell, BlackKingCell) - Distance(SourceCell, WhiteKingCell) - (2*Board.ToPlay-1)];
      end                                                                                                                                   // -1 for black to move, +1 if white to move
     else
      begin
      if (UInt64($1) shl (SourceCell + 8) and (Board.WhitePegs or Board.BlackPegs)) = 0 then      // square in front is unoccupied, can advance
        begin
        PawnAdvancePeg := UInt64($1) shl (SourceCell + 8);
        if ((AttackedbyWhite and PawnAdvancePeg) <> 0) then                     // next square attacked by white
          begin
          if ((AttackedbyBlack and PawnAdvancePeg) = 0) then                    // next square not defended by black
            PassedPawnBonus := PassedPawnBonus - PasserBlockedPenaltyB_eg       // passer can be captured on next square
          end
         else
          PassedPawnBonus := PassedPawnBonus - PasserCanAdvanceBonusA_eg;       // passer can safely advance
        end
       else
        PassedPawnBonus := PassedPawnBonus - PasserBlockedPenaltyA_eg;          // square in front is blocked

      // king proximity bonus
      PassedPawnBonus := PassedPawnBonus - KingProximityBonusB_eg[Distance(SourceCell, BlackKingCell) - Distance(SourceCell, WhiteKingCell)];
      end;
    end;


  Tempo := (1 - 2 * Board.ToPlay) * Tempo_Bonus_mg;
  PST_mg := PST_mg + Tempo;

  Tempo := (1 - 2 * Board.ToPlay) * Tempo_Bonus_eg;
  PST_eg := PST_eg + PassedPawnBonus + Tempo;

  PST := (PST_mg * Board.GameStage + PST_eg * (64 - Board.GameStage)) div 64;

  dQ := QP_ImBalFactor*Pdif + QN_ImBalFactor*Ndif + QB_ImBalFactor* Bdif + QR_ImBalFactor*Rdif;
  dR := RP_ImBalFactor*Pdif + RN_ImBalFactor*Ndif + RB_ImBalFactor* Bdif;
  dB := BP_ImBalFactor*Pdif + BN_ImBalFactor*Ndif;
  dN := NP_ImBalFactor*Pdif;

  PieceBonus := PieceBonus + dQ * bitcount(Board.Queens);
  PieceBonus := PieceBonus + dR * bitcount(Board.Rooks);
  PieceBonus := PieceBonus + dB * bitcount(Board.Bishops);
  PieceBonus := PieceBonus + dN * bitcount(Board.Knights);


  if Board.ToPlay = white then
    begin
    if Board.PawnsOnly(Black) then
      KingAttack := KingAttack + WhitePrecinctPawnCount * KingAttackPawnsOnly
     else
      KingAttack := KingAttack + KingAttack_STM[BlackPrecinctIndex, BlackPrecinctPawnCount, min(12, BlackKingAttackIndex)];

    if Board.PawnsOnly(White) then
      KingAttack := KingAttack - BlackPrecinctPawnCount * KingAttackPawnsOnly
     else
      KingAttack := KingAttack - KingAttack_OTM[WhitePrecinctIndex, WhitePrecinctPawnCount, min(12, WhiteKingAttackIndex)];
    end
   else
    begin
    if Board.PawnsOnly(Black) then
      KingAttack := KingAttack + WhitePrecinctPawnCount * KingAttackPawnsOnly
     else
      KingAttack := KingAttack + KingAttack_OTM[BlackPrecinctIndex, BlackPrecinctPawnCount, min(12, BlackKingAttackIndex)];

    if Board.PawnsOnly(White) then
      KingAttack := KingAttack - BlackPrecinctPawnCount * KingAttackPawnsOnly
     else
      KingAttack := KingAttack - KingAttack_STM[WhitePrecinctIndex, WhitePrecinctPawnCount, min(12, WhiteKingAttackIndex)];
    end;

  result := Mobility + PST + MatBal + PieceBonus + AttackBonus + DefenderBonus + KingAttack;
  end;


function ScoreFromBoard(const Board : TBoard) : integer;
  var
    PawnEval : integer;
    MatHashWhite, MatHashBlack, EndGameHash, PawnEvalHash : UInt64;
    Passers : UInt64;
    EvalFunction : TEvalFunction;

  begin
  if EvalHashTable.RetrieveScore(Board.Hash, result) = false then
    begin
    PawnEval := 0;
    Passers := 0;

    if Board.Pawns <> 0 then
      begin
      PawnEvalHash := Board.PawnHash xor (UInt64(Board.GameStage) * $5369DEB);
      if PawnHashTable.RetrieveData(PawnEvalHash, PawnEval, Passers) = false then
        begin
        PawnEval := PawnBonus(Board, Passers);
        PawnHashTable.StoreData(PawnEvalHash, PawnEval, Passers);
        end;
      end;

    result := EvalCalc(Board, Passers) + PawnEval;

    if bitcount(Board.WhitePegs or Board.BlackPegs) <= 5 then
      begin
      MatHashWhite := WhiteMaterialHashFromBoard(Board);
      MatHashBlack := BlackMaterialHashFromBoard(Board);

      EndGameHash := MatHashWhite xor MatHashBlack;

      EvalFunction := EndGameTable.RetrieveEval(EndGameHash);
      if assigned(EvalFunction) then
        result := EvalFunction(Board, result);
      end;

    EvalHashTable.StoreScore(Board.Hash, result);
    end;

  if Board.ToPlay = Black then
    result := -result;
  end;


function RemainingMoveCountEstimate(const Board : TBoard) : integer;
// source: 'Time Management Procedure in Computer Chess', Vladan Vuckovic & Rade Solak

  var
    Stage : integer;

  begin

  stage := min(80, Board.GameStage + BitCount(Board.Pawns));

  if stage < 20 then
    result := stage + 20                 // my adjustment added + 16
   else if stage <= 50 then
    result := (3 * stage) div 8 + 30     // my adjustment added + 8
   else
    result := (5 * stage) div 4 - 10;    // my adjustment added + 20

  result := result div 2;

  end;


function RemainingMoveCountEstimate_Alt(const Board : TBoard; MoveNumber : UInt64) : integer;
  var
    calc : double;

  begin
  if MoveNumber < 200 then
    calc := ((((((-2.617136000E-09 * MoveNumber) + 1.517155086E-06) * MoveNumber -3.293926387E-04) * MoveNumber) + 3.228622557E-02) * MoveNumber - 1.4085982) * MoveNumber + 51.726835
   else
    calc := 16;
  result := trunc(calc);
  end;


function Q_Eval(alpha, beta: Integer; var Board : TBoard; PrevMove : TMove): integer;

// Used to estimate score of a board position, taking into account any material exchange that may be in progress
// so need estimate of score after exchange is complete i.e. scored position is quiet
// This "score" is used to estimate moves left in the game for time control purposes

  var
    k : integer;
    value  : integer;
    Moves : TMoveArray;
    Movecount : integer;

  begin
  value := ScoreFromBoard(Board);

  if value >= beta then
    exit(value);

  if alpha < value then
    alpha := value;

  // Get Moves to investigate
  // Capture and Promotion Moves only, - no quiet moves

  movecount := Board.GetAllValidMoves(Board.ToPlay, Moves, true);

  //  Evaluate

  if (movecount = 0) then
    exit(alpha);     // no more violent moves left

  if movecount > 1 then
    begin
    RateMovesQ(Moves);
    SortMoves(Moves);
    end;

  // Search

  for k := 1 to movecount do
    begin

    Board.MakeMove(Moves[k]);

    value := -Q_Eval(-beta, -alpha, Board, Moves[k]);

    Board.UndoMove(Moves[k]);

    if value >= beta then
      exit(value);

    if value > alpha then
     alpha := value;
    end;

  result := alpha;
  end;


Initialization

  ReportMemoryLeaksOnShutDown := true;
  PawnHashTable.ClearTable;
  EvalHashTable.ClearTable;

end.
